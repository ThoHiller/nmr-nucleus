<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of runInversionJoint</title>
  <meta name="keywords" content="runInversionJoint">
  <meta name="description" content=" controls the joint inversion process to infer a pore size">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # nucleus --><!-- # functions --><!-- menu.html interface -->
<h1>runInversionJoint
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong> controls the joint inversion process to infer a pore size</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function runInversionJoint </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">runInversionJoint controls the joint inversion process to infer a pore size
distribution (PSD) from NMR and CPS data

 Syntax:
       runInversionJoint

 Inputs:
       none

 Outputs:
       none

 Example:
       runInversionJoint

 Other m-files required:
       checkIfInversionExists
       clearSingleAxis
       displayStatusText
       fcn_JointInvfixed
       fcn_JointInvfree
       fcn_JointInvshape
       getChi2
       getLambdaFromRMS
       getConstants
       getCornerNMRparameter
       getGeometryParameter
       getPartialSaturationMatrix    
       getSaturationFromPressureBatch
       onPushRun
       onPushShowHide
       onPushStop
       removeInversionFields    
       updateInfo
       updatePlotsJointInversion    
       updatePlotsLcurve</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../nucleus/callbacks/push/onPushRun.html" class="code" title="function onPushRun(src,~)">onPushRun</a>	 handles the callbacks to all RUN push buttons in both GUIs and</li><li><a href="../../../nucleus/callbacks/push/onPushShowHide.html" class="code" title="function onPushShowHide(src,~)">onPushShowHide</a>	 shows/hides the INFO column on the right side of NUCLEUSinv</li><li><a href="../../../nucleus/callbacks/push/onPushStop.html" class="code" title="function onPushStop(src,~)">onPushStop</a>	 recognizes that a STOP push button was pressed and resets the</li><li><a href="checkIfInversionExists.html" class="code" title="function [foundINV,N] = checkIfInversionExists(INVdata)">checkIfInversionExists</a>	 checks if any inversion result is stored inside</li><li><a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>	 clears an individual axis</li><li><a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>	 clears all axes of a given figure</li><li><a href="removeInversionFields.html" class="code" title="function data = removeInversionFields(data)">removeInversionFields</a>	 deletes all inversion result fields from NUCLEUSinv</li><li><a href="updateInfo.html" class="code" title="function updateInfo(src,~) %#ok<INUSD>">updateInfo</a>	 updates the information shown in all information list boxes</li><li><a href="updatePlotsJointInversion.html" class="code" title="function updatePlotsJointInversion">updatePlotsJointInversion</a>	 plots the joint-inversion results in NUCLEUSinv</li><li><a href="updatePlotsLcurve.html" class="code" title="function updatePlotsLcurve">updatePlotsLcurve</a>	 plots the results of the L-curve calculation</li><li><a href="../../../nucleus/functions/inversion/fcn_JointInvfixed.html" class="code" title="function [F,varargout] = fcn_JointInvfixed(X,iparam)">fcn_JointInvfixed</a>	 performs the "fixed" joint inversion using the RTD of</li><li><a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>	 jointly estimates the pore size distribution and surface</li><li><a href="../../../nucleus/functions/inversion/fcn_JointInvshape.html" class="code" title="function [F,varargout] = fcn_JointInvshape(X,iparam)">fcn_JointInvshape</a>	 performs the "shape" joint inversion using the RTD of</li><li><a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>	 the chi2 of a NMR fit (noise weighted error quality)</li><li><a href="../../../nucleus/functions/inversion/getLambdaFromLCurve.html" class="code" title="function index = getLambdaFromLCurve(rho,eta,plotit)">getLambdaFromLCurve</a>	 estimates the regularization parameter lambda according</li><li><a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>	 provides some physical constants to the forward calculation</li><li><a href="../../../nucleus/functions/modeling/getCornerNMRparameter.html" class="code" title="function out = getCornerNMRparameter(geometry,SatData,indt,imbdrain)">getCornerNMRparameter</a>	 calculates corner parameters (amplitude surface to</li><li><a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>	 calculates geometric parameters for the three possible</li><li><a href="../../../nucleus/functions/modeling/getPartialSaturationMatrix.html" class="code" title="function IPS = getPartialSaturationMatrix(SatData,indt,imbdrain)">getPartialSaturationMatrix</a>	 calculates the partial saturation matrix to be</li><li><a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../nucleus/callbacks/push/onPushRun.html" class="code" title="function onPushRun(src,~)">onPushRun</a>	 handles the callbacks to all RUN push buttons in both GUIs and</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function runInversionJoint</a>
0002 <span class="comment">%runInversionJoint controls the joint inversion process to infer a pore size</span>
0003 <span class="comment">%distribution (PSD) from NMR and CPS data</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Syntax:</span>
0006 <span class="comment">%       runInversionJoint</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Inputs:</span>
0009 <span class="comment">%       none</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Outputs:</span>
0012 <span class="comment">%       none</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% Example:</span>
0015 <span class="comment">%       runInversionJoint</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% Other m-files required:</span>
0018 <span class="comment">%       checkIfInversionExists</span>
0019 <span class="comment">%       clearSingleAxis</span>
0020 <span class="comment">%       displayStatusText</span>
0021 <span class="comment">%       fcn_JointInvfixed</span>
0022 <span class="comment">%       fcn_JointInvfree</span>
0023 <span class="comment">%       fcn_JointInvshape</span>
0024 <span class="comment">%       getChi2</span>
0025 <span class="comment">%       getLambdaFromRMS</span>
0026 <span class="comment">%       getConstants</span>
0027 <span class="comment">%       getCornerNMRparameter</span>
0028 <span class="comment">%       getGeometryParameter</span>
0029 <span class="comment">%       getPartialSaturationMatrix</span>
0030 <span class="comment">%       getSaturationFromPressureBatch</span>
0031 <span class="comment">%       onPushRun</span>
0032 <span class="comment">%       onPushShowHide</span>
0033 <span class="comment">%       onPushStop</span>
0034 <span class="comment">%       removeInversionFields</span>
0035 <span class="comment">%       updateInfo</span>
0036 <span class="comment">%       updatePlotsJointInversion</span>
0037 <span class="comment">%       updatePlotsLcurve</span>
0038 
0039 <span class="comment">%</span>
0040 <span class="comment">% Subfunctions:</span>
0041 <span class="comment">%       none</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% MAT-files required:</span>
0044 <span class="comment">%       none</span>
0045 <span class="comment">%</span>
0046 <span class="comment">% See also: NUCLEUSinv</span>
0047 <span class="comment">% Author: Thomas Hiller</span>
0048 <span class="comment">% email: thomas.hiller[at]leibniz-liag.de</span>
0049 <span class="comment">% License: MIT License (at end)</span>
0050 
0051 <span class="comment">%------------- BEGIN CODE --------------</span>
0052 
0053 <span class="comment">%% get GUI handle and data</span>
0054 fig = findobj(<span class="string">'Tag'</span>,<span class="string">'INV'</span>);
0055 gui = getappdata(fig,<span class="string">'gui'</span>);
0056 data = getappdata(fig,<span class="string">'data'</span>);
0057 INVdata = getappdata(fig,<span class="string">'INVdata'</span>);
0058 
0059 <span class="comment">% check if there is any inversion results at all</span>
0060 foundINV = <a href="checkIfInversionExists.html" class="code" title="function [foundINV,N] = checkIfInversionExists(INVdata)">checkIfInversionExists</a>(INVdata);
0061 
0062 <span class="comment">%% if yes continue</span>
0063 <span class="keyword">if</span> foundINV    
0064     <span class="comment">% check which signals have been inverted before</span>
0065     <span class="comment">% (E0 is needed for Sat-normalization)</span>
0066     nINV = size(INVdata,1);
0067     E0 = zeros(nINV,1);
0068     c = 0;
0069     <span class="keyword">for</span> i = 1:nINV
0070         <span class="keyword">if</span> isstruct(INVdata{i})
0071             c = c + 1;
0072             E0(i,1) = sum(INVdata{i}.results.invstd.E0);
0073             invlevels(c) = i; <span class="comment">%#ok&lt;*AGROW&gt;</span>
0074             invtype{c} = INVdata{i}.invstd.invtype;
0075             gatetype{c} = INVdata{i}.results.nmrproc.gatetype;
0076         <span class="keyword">end</span>
0077     <span class="keyword">end</span>    
0078     <span class="comment">% for &quot;fixed&quot; and &quot;shape&quot; inversion a RTD is needed</span>
0079     InvtypeIsOK = false;
0080     <span class="keyword">switch</span> data.invjoint.invtype
0081         <span class="keyword">case</span> {<span class="string">'fixed'</span>,<span class="string">'shape'</span>}
0082             <span class="keyword">switch</span> invtype{1}
0083                 <span class="keyword">case</span> {<span class="string">'LU'</span>,<span class="string">'NNLS'</span>}
0084                     InvtypeIsOK = true;
0085                 <span class="keyword">otherwise</span>
0086                     <span class="comment">% nothing to do</span>
0087             <span class="keyword">end</span>
0088         <span class="keyword">otherwise</span>
0089             InvtypeIsOK = true;
0090     <span class="keyword">end</span>
0091     <span class="comment">% check if the gatetype is for all signals the same</span>
0092     GatetypeIsOK = false;
0093     <span class="keyword">if</span> numel(unique(gatetype)) == 1
0094         GatetypeIsOK = true;
0095     <span class="keyword">end</span>
0096     
0097     <span class="comment">% the pressure / saturation data</span>
0098     table = data.pressure.table;
0099     uselevel = cell2mat(table(:,1));
0100     tablelevels = 1:size(table,1);
0101     tablelevels = tablelevels(uselevel);
0102     
0103     <span class="comment">% get the union of inverted signals and check marks in the CPS table</span>
0104     [isin,levels] = ismember(invlevels,tablelevels);
0105     levels = tablelevels(levels(isin));
0106     
0107     <span class="comment">% at least the first one should be there and the inversion type should</span>
0108     <span class="comment">% be okay</span>
0109     <span class="keyword">if</span> any(levels==1) &amp;&amp; InvtypeIsOK &amp;&amp; GatetypeIsOK
0110         <span class="comment">% the pressure / saturation data</span>
0111         table = data.pressure.table;
0112         p0 = cell2mat(table(:,2));
0113         S0 = cell2mat(table(:,3));
0114         SatImbDrain = cell2mat(table(:,4))';
0115         <span class="comment">% used for inversion</span>
0116         p = p0(levels);
0117         S = S0(levels);
0118         SatImbDrain = SatImbDrain(levels);
0119         
0120         <span class="comment">% the NMR signals used for inversion</span>
0121         <span class="keyword">for</span> i = 1:numel(levels)
0122             idata.nmr{levels(i)}.name = data.import.NMR.filesShort{levels(i)};
0123             idata.nmr{levels(i)}.t0 = INVdata{levels(i)}.results.nmrproc.t;
0124             idata.nmr{levels(i)}.g0 = S(i).*<span class="keyword">...</span>
0125                 (INVdata{levels(i)}.results.nmrproc.s./E0(levels(i)));
0126             idata.nmr{levels(i)}.t = INVdata{levels(i)}.results.nmrproc.t;
0127             idata.nmr{levels(i)}.g = S(i).*<span class="keyword">...</span>
0128                 (INVdata{levels(i)}.results.nmrproc.s./E0(levels(i)));
0129             idata.nmr{levels(i)}.N = INVdata{levels(i)}.results.nmrproc.N;
0130             idata.nmr{levels(i)}.noise = S(i).*<span class="keyword">...</span>
0131                 (INVdata{levels(i)}.results.nmrproc.noise./E0(levels(i)));
0132             idata.nmr{levels(i)}.e = idata.nmr{levels(i)}.noise./<span class="keyword">...</span>
0133                 sqrt(idata.nmr{levels(i)}.N);
0134             
0135             <span class="comment">% switch depending on inversion method</span>
0136             <span class="keyword">switch</span> data.invjoint.invtype
0137                 <span class="keyword">case</span> <span class="string">'free'</span>
0138                     <span class="comment">% T1 or T2 data?</span>
0139                     <span class="keyword">if</span> levels(i) == 1
0140                         T1T2flag = INVdata{levels(i)}.results.nmrproc.T1T2;
0141                         T1IRfac = INVdata{levels(i)}.results.nmrproc.T1IRfac;
0142                     <span class="keyword">end</span>
0143                 <span class="keyword">case</span> {<span class="string">'fixed'</span>,<span class="string">'shape'</span>}
0144                     <span class="keyword">if</span> levels(i) == 1
0145                         <span class="comment">% full saturation RTD</span>
0146                         fullsat.T = INVdata{levels(i)}.results.invstd.T1T2me;
0147                         fullsat.F = S(i).*<span class="keyword">...</span>
0148                             (INVdata{levels(i)}.results.invstd.T1T2f./<span class="keyword">...</span>
0149                             sum(INVdata{levels(i)}.results.invstd.T1T2f));
0150                         <span class="comment">% T1 or T2 data?</span>
0151                         T1T2flag = INVdata{levels(i)}.results.nmrproc.T1T2;
0152                         T1IRfac = INVdata{levels(i)}.results.nmrproc.T1IRfac;
0153                     <span class="keyword">end</span>
0154             <span class="keyword">end</span>
0155         <span class="keyword">end</span>
0156         
0157         <span class="comment">% stack all NMR signals into one long vector</span>
0158         c = 0;
0159         indt = zeros(size(levels));
0160         <span class="keyword">for</span> i = 1:numel(levels)
0161             c = c + 1;
0162             <span class="keyword">if</span> c == 1
0163                 t = idata.nmr{levels(i)}.t';
0164                 g = idata.nmr{levels(i)}.g';
0165                 e = idata.nmr{levels(i)}.e';
0166                 N = idata.nmr{levels(i)}.N';
0167             <span class="keyword">else</span>
0168                 t = [t idata.nmr{levels(i)}.t'];
0169                 g = [g idata.nmr{levels(i)}.g'];
0170                 e = [e idata.nmr{levels(i)}.e'];
0171                 N = [N idata.nmr{levels(i)}.N'];
0172             <span class="keyword">end</span>
0173             indt(c) = length(idata.nmr{levels(i)}.t);
0174         <span class="keyword">end</span>
0175         
0176         <span class="comment">% create the error weighing matrix</span>
0177         <span class="keyword">if</span> strcmp(unique(gatetype),<span class="string">'log'</span>) || strcmp(unique(gatetype),<span class="string">'lin'</span>)
0178             W = diag(e);
0179             useW = true;
0180         <span class="keyword">else</span>
0181             useW = false;
0182         <span class="keyword">end</span>
0183         
0184         <span class="comment">% inversion output on the command line</span>
0185         <span class="keyword">switch</span> data.info.InvInfo
0186             <span class="keyword">case</span> <span class="string">'on'</span>
0187                 info = <span class="string">'iter'</span>;
0188             <span class="keyword">case</span> <span class="string">'off'</span>
0189                 info = <span class="string">'off'</span>;
0190         <span class="keyword">end</span>
0191         
0192         <span class="comment">% switch depending on inversion method</span>
0193         <span class="keyword">switch</span> data.invjoint.invtype            
0194             <span class="keyword">case</span> <span class="string">'free'</span>
0195                 <span class="comment">% radii distribution</span>
0196                 r_start = log10(data.invjoint.radii(1));
0197                 r_end = log10(data.invjoint.radii(2));
0198                 r = logspace(r_start,r_end,(r_end-r_start)*data.invjoint.Nradii);
0199                 
0200                 <span class="comment">% inversion geometry</span>
0201                 igeom.type = data.invjoint.geometry_type;
0202                 igeom.angles = [data.invjoint.alpha data.invjoint.beta data.invjoint.gamma];
0203                 igeom.polyN = data.invjoint.polyN;
0204                 igeom.radius = r';
0205                 igeom = <a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>(igeom);
0206                 
0207                 <span class="comment">% saturation for the inversion model</span>
0208                 ipsddata.r = igeom.radius';
0209                 ipsddata.psd = ones(size(ipsddata.r));
0210                 <span class="comment">% wait-bar option</span>
0211                 wbopts.show = false;
0212                 wbopts.tag = <span class="string">'INV'</span>;
0213                 iSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(igeom,p,ipsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0214                 IPS = <a href="../../../nucleus/functions/modeling/getPartialSaturationMatrix.html" class="code" title="function IPS = getPartialSaturationMatrix(SatData,indt,imbdrain)">getPartialSaturationMatrix</a>(iSAT,indt,SatImbDrain);
0215                 <span class="comment">% get the amplitudes and surface to volume ratios for all shapes</span>
0216                 SVdata = <a href="../../../nucleus/functions/modeling/getCornerNMRparameter.html" class="code" title="function out = getCornerNMRparameter(geometry,SatData,indt,imbdrain)">getCornerNMRparameter</a>(igeom,iSAT,indt,SatImbDrain);
0217                 SVdata.TT = repmat(t',[1 length(SVdata.SVF)]);
0218                 
0219                 <span class="comment">% derivative matrix</span>
0220                 L = get_l(length(ipsddata.r),data.invjoint.Lorder);
0221                 
0222                 <span class="comment">% switch depending on regularization method</span>
0223                 <span class="keyword">switch</span> data.invjoint.regtype                    
0224                     <span class="keyword">case</span> <span class="string">'lcurve'</span>
0225                         <span class="comment">% clear axes</span>
0226                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.all);
0227                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.rtd);
0228                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.psd);
0229                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.psdj);
0230                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.cps);
0231                         
0232                         <span class="comment">% make the RUN button a STOP button</span>
0233                         <span class="comment">% set &quot;UserData&quot; to 1 to catch a STOP button event</span>
0234                         set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'STOP'</span>,<span class="keyword">...</span>
0235                             <span class="string">'BackGroundColor'</span>,<span class="string">'r'</span>,<span class="string">'UserData'</span>,1,<span class="string">'Callback'</span>,@<a href="../../../nucleus/callbacks/push/onPushStop.html" class="code" title="function onPushStop(src,~)">onPushStop</a>);
0236                         
0237                         <span class="comment">% no command line output during l-curve calculation</span>
0238                         info = <span class="string">'off'</span>;
0239                         
0240                         <span class="comment">% lambda range and initialization of output variables</span>
0241                         lambda_range = logspace(log10(data.invjoint.lambdaR(1)),<span class="keyword">...</span>
0242                             log10(data.invjoint.lambdaR(2)),data.invjoint.NlambdaR);
0243                         RMS = zeros(size(lambda_range));
0244                         XN = zeros(size(lambda_range));
0245                         RN = zeros(size(lambda_range));
0246                         
0247                         <span class="comment">% status bar information</span>
0248                         infostring = <span class="string">'L-Curve calculation ... '</span>;
0249                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0250                         
0251                         <span class="comment">% wait-bar option</span>
0252                         wbopts.show = true;
0253                         wbopts.tag = <span class="string">'INV'</span>;
0254                         <span class="keyword">if</span> wbopts.show
0255                             hwb = waitbar(0,<span class="string">'processing ...'</span>,<span class="string">'Name'</span>,<span class="string">'L-Curve calculation'</span>,<span class="string">'Visible'</span>,<span class="string">'off'</span>);
0256                             steps = length(lambda_range);
0257                             fig = findobj(<span class="string">'Tag'</span>,wbopts.tag);
0258                             <span class="keyword">if</span> ~isempty(fig)
0259                                 posf = get(fig,<span class="string">'Position'</span>);
0260                                 set(hwb,<span class="string">'Units'</span>,<span class="string">'Pixel'</span>)
0261                                 posw = get(hwb,<span class="string">'Position'</span>);
0262                                 set(hwb,<span class="string">'Position'</span>,[posf(1)+posf(3)/2-posw(3)/2 posf(2)+posf(4)/2-posw(4)/2 posw(3:4)]);
0263                             <span class="keyword">end</span>
0264                             set(hwb,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
0265                         <span class="keyword">end</span>
0266                         
0267                         <span class="comment">% the L-curve calculation</span>
0268                         <span class="keyword">for</span> i = 1:length(lambda_range)
0269                             <span class="comment">% check if the STOP button was pressed</span>
0270                             <span class="comment">% if &quot;UserData&quot; is 1 STOP was not pressed -&gt; continue</span>
0271                             <span class="keyword">if</span> get(gui.push_handles.invjoint_run,<span class="string">'UserData'</span>) == 1
0272                                 
0273                                 iparam.t = t;
0274                                 iparam.g = g;
0275                                 <span class="keyword">if</span> useW
0276                                     iparam.W = W;
0277                                 <span class="keyword">end</span>
0278                                 iparam.Tb = data.invstd.Tbulk;
0279                                 iparam.T1T2 = T1T2flag;
0280                                 iparam.T1IRfac = T1IRfac;
0281                                 iparam.L = L;
0282                                 iparam.lambda = lambda_range(i);
0283                                 iparam.igeom = igeom;
0284                                 iparam.IPS = IPS;
0285                                 iparam.SVdata = SVdata;
0286                                 iparam.SatImbDrain = SatImbDrain;
0287                                 
0288                                 <span class="comment">% start values and bounds</span>
0289                                 rhostart = log10(data.invjoint.rhostart/1e6);
0290                                 rhobounds = log10(data.invjoint.rhobounds/1e6);
0291                                 x0 = [zeros(size(igeom.radius))' rhostart];
0292                                 lb = [zeros(size(igeom.radius))' rhobounds(1)];
0293                                 ub = [ones(size(igeom.radius))' rhobounds(2)];
0294                                 
0295                                 options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="keyword">...</span>
0296                                     <span class="string">'Jacobian'</span>,<span class="string">'on'</span>,<span class="string">'DerivativeCheck'</span>,<span class="string">'off'</span>,<span class="string">'FinDiffType'</span>,<span class="string">'central'</span>,<span class="keyword">...</span>
0297                                     <span class="string">'Algorithm'</span>,<span class="string">'levenberg-marquardt'</span>,<span class="keyword">...</span>
0298                                     <span class="string">'MaxIter'</span>,1000);
0299                                 
0300                                 [X,~,~,~] = lsqnonlin(@(X)<a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam),x0,lb,ub,options);
0301                                 [~,~,ig,~] = <a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam);
0302                                 
0303                                 <span class="keyword">if</span> useW
0304                                     <span class="comment">% normalize the fit because the signal was error</span>
0305                                     <span class="comment">% weighted for the inversion</span>
0306                                     e = diag(iparam.W);
0307                                     einv = 1./e;
0308                                     Winv = diag(einv);
0309                                     ig = Winv * ig;
0310                                 <span class="keyword">end</span>
0311                         
0312                                 residual = ig - g';
0313                                 iF = X(1:length(X)-1);
0314                                 
0315                                 <span class="comment">% output data</span>
0316                                 <span class="comment">% get RMS and X^2</span>
0317                                 <span class="keyword">if</span> useW
0318                                     <span class="comment">% weighted RMS error</span>
0319                                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0320                                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0321                                     RMS(i) = sqrt (sum(N'.*(residual).^2) / length(residual));
0322                                     <span class="comment">% X2 estimate</span>
0323                                     CHI2(i) = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0324                                 <span class="keyword">else</span>
0325                                     <span class="comment">% RMS error</span>
0326                                     RMS(i) = sqrt( sum(residual.^2) / length(residual) );
0327                                     <span class="comment">% X2 estimate</span>
0328                                     CHI2(i) = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0329                                 <span class="keyword">end</span>
0330                                 <span class="comment">% error norm and model norm</span>
0331                                 RN(i) = norm(residual,2);
0332                                 XN(i) = norm(L*iF',2);
0333                                 <span class="comment">% wait-bar update</span>
0334                                 <span class="keyword">if</span> wbopts.show
0335                                     waitbar(i / steps,hwb,[<span class="string">'processing ...'</span>,num2str(i),<span class="string">' / '</span>,num2str(steps),<span class="string">' lambda steps'</span>]);
0336                                 <span class="keyword">end</span>
0337                             <span class="keyword">end</span>
0338                         <span class="keyword">end</span>                        
0339                         <span class="comment">% delete the wait-bar</span>
0340                         <span class="keyword">if</span> wbopts.show
0341                             delete(hwb);
0342                         <span class="keyword">end</span>
0343                         
0344                         <span class="comment">% check if the STOP button was pressed</span>
0345                         <span class="comment">% if &quot;UserData&quot; is 1 STOP was not pressed -&gt; save data</span>
0346                         <span class="keyword">if</span> get(gui.push_handles.invjoint_run,<span class="string">'UserData'</span>) == 1
0347                             lc.lambda = lambda_range;
0348                             lc.RMS = RMS;
0349                             lc.RN = RN;
0350                             lc.XN = XN;
0351                             <span class="comment">% get optimal lambda</span>
0352 <span class="comment">%                             lc.index = getLambdaFromRMS(lc.lambda,lc.RMS,0);</span>
0353                             lc.index = <a href="../../../nucleus/functions/inversion/getLambdaFromLCurve.html" class="code" title="function index = getLambdaFromLCurve(rho,eta,plotit)">getLambdaFromLCurve</a>(RN,XN,0);
0354                             data.results.lcurve = lc;
0355                             <span class="comment">% update GUI data</span>
0356                             setappdata(fig,<span class="string">'data'</span>,data);
0357                             <span class="comment">% update L-curve plots</span>
0358                             <a href="updatePlotsLcurve.html" class="code" title="function updatePlotsLcurve">updatePlotsLcurve</a>;
0359                             <span class="comment">% status bar information</span>
0360                             <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">' done'</span>]);
0361                             <span class="comment">% set focus on results</span>
0362                             set(gui.plots.DistPanel,<span class="string">'Selection'</span>,1);
0363                         <span class="keyword">else</span>
0364                             <span class="comment">% status bar information</span>
0365                             <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">' was canceled'</span>]);
0366                             <span class="comment">% remove temporary data fields</span>
0367                             data = <a href="removeInversionFields.html" class="code" title="function data = removeInversionFields(data)">removeInversionFields</a>(data);
0368                         <span class="keyword">end</span>
0369                         
0370                     <span class="keyword">case</span> <span class="string">'manual'</span>
0371                         <span class="comment">% disable the RUN button to indicate a running inversion</span>
0372                         set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'RUNNING ...'</span>,<span class="keyword">...</span>
0373                             <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);  
0374             
0375                         <span class="comment">% inversion parameter</span>
0376                         iparam.t = t;
0377                         iparam.g = g;
0378                         <span class="keyword">if</span> useW
0379                             iparam.W = W;
0380                         <span class="keyword">end</span>
0381                         iparam.Tb = data.invstd.Tbulk;
0382                         iparam.T1T2 = T1T2flag;
0383                         iparam.T1IRfac = T1IRfac;
0384                         iparam.L = L;
0385                         iparam.lambda = data.invjoint.lambda;
0386                         iparam.igeom = igeom;
0387                         iparam.IPS = IPS;
0388                         iparam.SVdata = SVdata;
0389                         iparam.SatImbDrain = SatImbDrain;
0390                         
0391                         <span class="comment">% start values and bounds</span>
0392                         rhostart = log10(data.invjoint.rhostart/1e6);
0393                         rhobounds = log10(data.invjoint.rhobounds/1e6);
0394                         x0 = [zeros(size(igeom.radius))' rhostart];
0395                         lb = [zeros(size(igeom.radius))' rhobounds(1)];
0396                         ub = [ones(size(igeom.radius))' rhobounds(2)];
0397                         
0398                         <span class="comment">% status bar information</span>
0399                         infostring = <span class="string">'Joint Inversion (free) using ''lsqnonlin'' ... '</span>;
0400                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0401                         
0402                         <span class="comment">% optimization settings</span>
0403                         options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="keyword">...</span>
0404                             <span class="string">'Jacobian'</span>,<span class="string">'on'</span>,<span class="string">'DerivativeCheck'</span>,<span class="string">'off'</span>,<span class="string">'FinDiffType'</span>,<span class="string">'central'</span>,<span class="keyword">...</span>
0405                             <span class="string">'Algorithm'</span>,<span class="string">'levenberg-marquardt'</span>,<span class="keyword">...</span>
0406                             <span class="string">'MaxIter'</span>,1000);
0407                         [X,~,~,exitflag] = lsqnonlin(@(X)<a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam),x0,lb,ub,options);
0408                         <span class="comment">% status bar information</span>
0409                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0410                         <span class="comment">% get the final fit</span>
0411                         [~,~,ig,KK] = <a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam);
0412                         
0413                         <span class="keyword">if</span> useW
0414                             <span class="comment">% normalize the fit because the signal was error</span>
0415                             <span class="comment">% weighted for the inversion</span>
0416                             e = diag(iparam.W);
0417                             einv = 1./e;
0418                             Winv = diag(einv);
0419                             ig = Winv * ig;
0420                         <span class="keyword">end</span>
0421                 
0422                         <span class="comment">% the inverted surface relaxivity and PSD</span>
0423                         iF = X(1:length(X)-1);
0424                         irho = 10^X(length(X));
0425                         <span class="comment">% inversion output</span>
0426                         data.results.invjoint.p0 = p0;
0427                         data.results.invjoint.S0 = S0;
0428                         data.results.invjoint.levels = levels;
0429                         data.results.invjoint.T1T2 = T1T2flag;
0430                         data.results.invjoint.T1IRfac = T1IRfac;
0431                         data.results.invjoint.x0 = x0;
0432                         data.results.invjoint.lb = lb;
0433                         data.results.invjoint.ub = ub;
0434                         data.results.invjoint.iparam = iparam;
0435                         data.results.invjoint.iGEOM = igeom;
0436                         data.results.invjoint.iSAT = iSAT;
0437                         data.results.invjoint.iF = iF';
0438                         data.results.invjoint.irho = irho;
0439                         data.results.invjoint.ig = ig;
0440                         data.results.invjoint.XX = KK;
0441                         data.results.invjoint.errnorm = norm((ig - g')).^2;
0442                         data.results.invjoint.residual = ig - g';
0443                         data.results.invjoint.exitflag = exitflag;
0444                         
0445                         <span class="comment">% get RMS and X^2</span>
0446                         residual = data.results.invjoint.residual;
0447                         <span class="keyword">if</span> useW
0448                             <span class="comment">% weighted RMS error</span>
0449                             <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0450                             <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0451                             data.results.invjoint.rms = sqrt (sum(N'.*(residual).^2) / length(residual));
0452                             <span class="comment">% X2 estimate</span>
0453                             data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0454                         <span class="keyword">else</span>
0455                             <span class="comment">% RMS error</span>
0456                             data.results.invjoint.rms = sqrt( sum(residual.^2) / length(residual) );
0457                             <span class="comment">% X2 estimate</span>
0458                             data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0459                         <span class="keyword">end</span>
0460                                                 
0461                         <span class="comment">% predict CPS curves for the final model</span>
0462                         infostring = <span class="string">'calculate CPS curve ... '</span>;
0463                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0464                         ppsddata.r = igeom.radius';
0465                         ppsddata.psd = data.results.invjoint.iF'./sum(data.results.invjoint.iF);
0466                         <span class="keyword">if</span> min(p) == 0
0467                             p_tmp = logspace(floor(log10(min(p(p&gt;0)))-2),ceil(log10(max(p)))+2,150);
0468                         <span class="keyword">else</span>
0469                             p_tmp = logspace(floor(log10(min(p)/2)),ceil(log10(max(p)))+2,150);
0470                         <span class="keyword">end</span>
0471                         <span class="comment">% waitbar option</span>
0472                         wbopts.show = true;
0473                         wbopts.tag = <span class="string">'INV'</span>;
0474                         pSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(igeom,p_tmp,ppsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0475                         <span class="comment">% save</span>
0476                         data.results.invjoint.pSAT = pSAT;
0477                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]); 
0478                 <span class="keyword">end</span>
0479                 
0480             <span class="keyword">case</span> <span class="string">'fixed'</span> <span class="comment">% only invert for rho</span>
0481                 <span class="comment">% disable the RUN button to indicate a running inversion</span>
0482                 set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'RUNNING ...'</span>,<span class="keyword">...</span>
0483                     <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);
0484                 
0485                 <span class="comment">% inversion geometry</span>
0486                 igeom.type = data.invjoint.geometry_type;
0487                 igeom.angles = [data.invjoint.alpha data.invjoint.beta data.invjoint.gamma];
0488                 igeom.polyN = data.invjoint.polyN;
0489                 igeom.radius = data.param.rho.*data.param.a.*fullsat.T; <span class="comment">% first guess</span>
0490                 igeom = <a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>(igeom);
0491                 
0492                 iparam.t = t;
0493                 iparam.g = g;
0494                 <span class="keyword">if</span> useW
0495                     iparam.W = W;
0496                 <span class="keyword">end</span>
0497                 iparam.indt = indt;
0498                 iparam.Tb = data.invstd.Tbulk;
0499                 iparam.T1T2 = T1T2flag;
0500                 iparam.T1IRfac = T1IRfac;
0501                 iparam.SatImbDrain = SatImbDrain;
0502                 iparam.p = p;
0503                 iparam.igeom = igeom;
0504                 iparam.x = fullsat.T';
0505                 iparam.f = fullsat.F';
0506                 
0507                 <span class="comment">% start values and bounds</span>
0508                 x0 = log10(data.invjoint.rhostart/1e6);
0509                 rhobounds = log10(data.invjoint.rhobounds/1e6);
0510                 lb = rhobounds(1);
0511                 ub = rhobounds(2);
0512                 
0513                 infostring = <span class="string">'Joint Inversion (fixed) using ''fminsearchbnd'' ... '</span>;
0514                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0515                 
0516                 options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="keyword">...</span>
0517                     <span class="string">'MaxFunEvals'</span>,300,<span class="string">'MaxIter'</span>,300);
0518                 X = fminsearchbnd(@(X) <a href="../../../nucleus/functions/inversion/fcn_JointInvfixed.html" class="code" title="function [F,varargout] = fcn_JointInvfixed(X,iparam)">fcn_JointInvfixed</a>(X,iparam),x0,lb,ub,options);
0519                 
0520                 [errnorm,ig,XX,iGEOM,iSAT] = <a href="../../../nucleus/functions/inversion/fcn_JointInvfixed.html" class="code" title="function [F,varargout] = fcn_JointInvfixed(X,iparam)">fcn_JointInvfixed</a>(X,iparam);
0521                 
0522                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0523                 
0524                 <span class="keyword">if</span> useW
0525                     <span class="comment">% normalize the fit because the signal was error</span>
0526                     <span class="comment">% weighted for the inversion</span>
0527                     e = diag(iparam.W);
0528                     einv = 1./e;
0529                     Winv = diag(einv);
0530                     ig = Winv * ig;
0531                 <span class="keyword">end</span>                
0532                 
0533                 <span class="comment">% inverted surface relaxivity</span>
0534                 irho = 10^X(1);
0535                 <span class="comment">% output data</span>
0536                 data.results.invjoint.p0 = p0;
0537                 data.results.invjoint.S0 = S0;
0538                 data.results.invjoint.levels = levels;
0539                 data.results.invjoint.T1T2 = T1T2flag;
0540                 data.results.invjoint.T1IRfac = T1IRfac;
0541                 data.results.invjoint.x0 = x0;
0542                 data.results.invjoint.lb = lb;
0543                 data.results.invjoint.ub = ub;
0544                 data.results.invjoint.iparam = iparam;
0545                 data.results.invjoint.iGEOM = iGEOM;
0546                 data.results.invjoint.iSAT = iSAT;
0547                 data.results.invjoint.iF = fullsat.F;
0548                 data.results.invjoint.irho = irho;
0549                 data.results.invjoint.ig = ig;
0550                 data.results.invjoint.XX = XX;
0551                 data.results.invjoint.errnorm = errnorm;
0552                 data.results.invjoint.residual = ig-g';
0553                 
0554                 <span class="comment">% get RMS and X^2</span>
0555                 residual = data.results.invjoint.residual;
0556                 <span class="keyword">if</span> useW
0557                     <span class="comment">% weighted RMS error</span>
0558                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0559                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0560                     data.results.invjoint.rms = sqrt (sum(N'.*(residual).^2) / length(residual));
0561                     <span class="comment">% X2 estimate</span>
0562                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0563                 <span class="keyword">else</span>
0564                     <span class="comment">% RMS error</span>
0565                     data.results.invjoint.rms = sqrt( sum(residual.^2) / length(residual) );
0566                     <span class="comment">% X2 estimate</span>
0567                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0568                 <span class="keyword">end</span>
0569                 
0570                 <span class="comment">% predict CPS curves from final model</span>
0571                 infostring = <span class="string">'calculate CPS curve ... '</span>;
0572                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0573                 ppsddata.r = iGEOM.radius';
0574                 ppsddata.psd = data.results.invjoint.iF'./sum(data.results.invjoint.iF);
0575                 <span class="keyword">if</span> min(p) == 0
0576                     p_tmp = logspace(floor(log10(min(p(p&gt;0)))-2),ceil(log10(max(p)))+2,150);
0577                 <span class="keyword">else</span>
0578                     p_tmp = logspace(floor(log10(min(p)/2)),ceil(log10(max(p)))+2,150);
0579                 <span class="keyword">end</span>
0580                 <span class="comment">% waitbar option</span>
0581                 wbopts.show = true;
0582                 wbopts.tag = <span class="string">'INV'</span>;
0583                 pSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(iGEOM,p_tmp,ppsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0584                 
0585                 data.results.invjoint.pSAT = pSAT;
0586                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0587                 
0588             <span class="keyword">case</span> <span class="string">'shape'</span> <span class="comment">% invert for rho and right angular shape</span>
0589                 <span class="comment">% disable the RUN button to indicate a running inversion</span>
0590                 set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'RUNNING ...'</span>,<span class="keyword">...</span>
0591                     <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);
0592                 
0593                 <span class="comment">% inversion geometry</span>
0594                 igeom.type = data.invjoint.geometry_type;
0595                 igeom.angles = [data.invjoint.alpha data.invjoint.beta data.invjoint.gamma];
0596                 igeom.polyN = data.invjoint.polyN;
0597                 igeom.radius = data.param.rho.*data.param.a.*fullsat.T; <span class="comment">% first guess</span>
0598                 igeom = <a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>(igeom);
0599                 
0600                 iparam.t = t;
0601                 iparam.g = g;
0602                 <span class="keyword">if</span> useW
0603                     iparam.W = W;
0604                 <span class="keyword">end</span>
0605                 iparam.indt = indt;
0606                 iparam.Tb = data.invstd.Tbulk;
0607                 iparam.T1T2 = T1T2flag;
0608                 iparam.T1IRfac = T1IRfac;
0609                 iparam.SatImbDrain = SatImbDrain;
0610                 iparam.p = p;
0611                 iparam.igeom = igeom;
0612                 iparam.x = fullsat.T';
0613                 iparam.f = fullsat.F';
0614                 
0615                 <span class="comment">% scale fit parameter between [0 1]</span>
0616                 <span class="comment">% x0 = [(log10(1e-6)+7)/3 data.invjoint.beta/45];</span>
0617                 <span class="comment">% lb = [(log10(1e-7)+7)/3 0.1/45];</span>
0618                 <span class="comment">% ub = [(log10(1e-4)+7)/3 45/45];</span>
0619                 <span class="comment">% old way</span>
0620                 x0 = [log10(data.invjoint.rhostart/1e6) data.invjoint.anglestart];
0621                 rhobounds = log10(data.invjoint.rhobounds/1e6);
0622                 lb = [rhobounds(1) 0.1];
0623                 ub = [rhobounds(2) 45];
0624                 
0625                 infostring = <span class="string">'Joint Inversion (shape) using ''fminsearchbnd'' ... '</span>;
0626                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0627                 options = optimset(<span class="string">'Display'</span>,<span class="string">'iter'</span>,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="string">'MaxIter'</span>,500);
0628                 options.Algorithm = <span class="string">'levenberg-marquardt'</span>;
0629                 options.MaxFunEvals = 500;
0630                 options.DiffMinChange = 1;
0631                 
0632                 options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-9,<span class="string">'TolX'</span>,1e-9,<span class="keyword">...</span>
0633                     <span class="string">'MaxFunEvals'</span>,300,<span class="string">'MaxIter'</span>,300);
0634                 X = fminsearchbnd(@(X) <a href="../../../nucleus/functions/inversion/fcn_JointInvshape.html" class="code" title="function [F,varargout] = fcn_JointInvshape(X,iparam)">fcn_JointInvshape</a>(X,iparam),x0,lb,ub,options);
0635                 
0636                 [errnorm,ig,XX,iGEOM,iSAT] = <a href="../../../nucleus/functions/inversion/fcn_JointInvshape.html" class="code" title="function [F,varargout] = fcn_JointInvshape(X,iparam)">fcn_JointInvshape</a>(X,iparam);
0637                 
0638                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0639                 
0640                 <span class="keyword">if</span> useW
0641                     <span class="comment">% normalize the fit because the signal was error</span>
0642                     <span class="comment">% weighted for the inversion</span>
0643                     e = diag(iparam.W);
0644                     einv = 1./e;
0645                     Winv = diag(einv);
0646                     ig = Winv * ig;
0647                 <span class="keyword">end</span>
0648                 
0649                 irho = 10^X(1);
0650                 ibeta = X(2);
0651                 
0652                 data.results.invjoint.p0 = p0;
0653                 data.results.invjoint.S0 = S0;
0654                 data.results.invjoint.levels = levels;
0655                 data.results.invjoint.T1T2 = T1T2flag;
0656                 data.results.invjoint.T1IRfac = T1IRfac;
0657                 data.results.invjoint.x0 = x0;
0658                 data.results.invjoint.lb = lb;
0659                 data.results.invjoint.ub = ub;
0660                 data.results.invjoint.iparam = iparam;
0661                 data.results.invjoint.iGEOM = iGEOM;
0662                 data.results.invjoint.iSAT = iSAT;
0663                 data.results.invjoint.iF = fullsat.F;
0664                 data.results.invjoint.irho = irho;
0665                 data.results.invjoint.ibeta = ibeta;
0666                 data.results.invjoint.ig = ig;
0667                 data.results.invjoint.XX = XX;
0668                 data.results.invjoint.errnorm = errnorm;
0669                 data.results.invjoint.residual = ig-g';
0670                 
0671                 <span class="comment">% get RMS and X^2</span>
0672                 residual = data.results.invjoint.residual;
0673                 <span class="keyword">if</span> useW
0674                     <span class="comment">% weighted RMS error</span>
0675                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0676                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0677                     data.results.invjoint.rms = sqrt (sum(N'.*(residual).^2) / length(residual));
0678                     <span class="comment">% X2 estimate</span>
0679                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0680                 <span class="keyword">else</span>
0681                     <span class="comment">% RMS error</span>
0682                     data.results.invjoint.rms = sqrt( sum(residual.^2) / length(residual) );
0683                     <span class="comment">% X2 estimate</span>
0684                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0685                 <span class="keyword">end</span>
0686                 
0687                 <span class="comment">% predict CPS curves from final model</span>
0688                 infostring = <span class="string">'calculate CPS curve ... '</span>;
0689                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0690                 ppsddata.r = iGEOM.radius';
0691                 ppsddata.psd = data.results.invjoint.iF'./sum(data.results.invjoint.iF);
0692                 <span class="keyword">if</span> min(p) == 0
0693                     p_tmp = logspace(floor(log10(min(p(p&gt;0)))-2),ceil(log10(max(p)))+2,150);
0694                 <span class="keyword">else</span>
0695                     p_tmp = logspace(floor(log10(min(p)/2)),ceil(log10(max(p)))+2,150);
0696                 <span class="keyword">end</span>
0697                 <span class="comment">% wait-bar option</span>
0698                 wbopts.show = true;
0699                 wbopts.tag = <span class="string">'INV'</span>;
0700                 pSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(iGEOM,p_tmp,ppsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0701                 
0702                 data.results.invjoint.pSAT = pSAT;
0703                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0704         <span class="keyword">end</span>
0705         
0706         <span class="comment">% if the regularization method was not L-curve then post process the</span>
0707         <span class="comment">% NMR data fits</span>
0708         <span class="keyword">if</span> ~strcmp(data.invjoint.regtype,<span class="string">'lcurve'</span>)
0709             <span class="comment">% get the individual NMR fits</span>
0710             <span class="keyword">for</span> i = 1:1:numel(levels)
0711                 idata.nmr{levels(i)}.fit_t = idata.nmr{levels(i)}.t;
0712                 <span class="keyword">if</span> i == 1
0713                     idata.nmr{levels(i)}.fit_g = ig(1:indt(1));
0714                 <span class="keyword">else</span>
0715                     idata.nmr{levels(i)}.fit_g = ig(sum(indt(1:i-1))+1:sum(indt(1:i-1))+indt(i));
0716                 <span class="keyword">end</span>
0717                 residual = idata.nmr{levels(i)}.fit_g - idata.nmr{levels(i)}.g;
0718                 
0719                 <span class="comment">% get RMS and X^2</span>
0720                 <span class="keyword">if</span> useW
0721                     <span class="comment">% weighted RMS error</span>
0722                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0723                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0724                     N = idata.nmr{levels(i)}.N;
0725                     rms = sqrt (sum(N.*(residual).^2) / length(residual));
0726                     <span class="comment">% X2 estimate</span>
0727                     chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(idata.nmr{levels(i)}.g,<span class="keyword">...</span>
0728                         idata.nmr{levels(i)}.fit_g,<span class="keyword">...</span>
0729                         idata.nmr{levels(i)}.e);
0730                 <span class="keyword">else</span>
0731                     <span class="comment">% RMS error</span>
0732                     rms = sqrt( sum(residual.^2) / length(residual) );
0733                     <span class="comment">% X2 estimate</span>
0734                     chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(idata.nmr{levels(i)}.g,<span class="keyword">...</span>
0735                         idata.nmr{levels(i)}.fit_g,<span class="keyword">...</span>
0736                         idata.nmr{levels(i)}.noise);
0737                 <span class="keyword">end</span>
0738 
0739                 idata.nmr{levels(i)}.residual = residual;
0740                 idata.nmr{levels(i)}.rms = rms;
0741                 idata.nmr{levels(i)}.chi2 = chi2;
0742             <span class="keyword">end</span>
0743             <span class="comment">% save the GUI data</span>
0744             data.results.invjoint.idata = idata;
0745             setappdata(fig,<span class="string">'data'</span>,data);
0746             
0747             <span class="comment">% save the &quot;INVdata&quot;</span>
0748             <span class="keyword">for</span> i = 1:1:numel(levels)
0749                 INVdata{levels(i)}.invjoint = data.invjoint;
0750                 INVdata{levels(i)}.pressure = data.pressure;
0751                 INVdata{levels(i)}.results.invjoint = data.results.invjoint;
0752             <span class="keyword">end</span>
0753             setappdata(fig,<span class="string">'INVdata'</span>,INVdata);
0754             <span class="comment">% update the plots</span>
0755             <a href="updatePlotsJointInversion.html" class="code" title="function updatePlotsJointInversion">updatePlotsJointInversion</a>;
0756             <span class="comment">% update the INFO fields</span>
0757             <a href="updateInfo.html" class="code" title="function updateInfo(src,~) %#ok<INUSD>">updateInfo</a>(gui.plots.SignalPanel);            
0758             <span class="comment">% set focus on results</span>
0759             set(gui.plots.SignalPanel,<span class="string">'Selection'</span>,3);
0760             set(gui.plots.DistPanel,<span class="string">'Selection'</span>,3);
0761             <span class="comment">% open INFO field</span>
0762             set(gui.push_handles.info,<span class="string">'String'</span>,<span class="string">'&lt;'</span>);
0763             <a href="../../../nucleus/callbacks/push/onPushShowHide.html" class="code" title="function onPushShowHide(src,~)">onPushShowHide</a>(gui.push_handles.info);
0764         <span class="keyword">end</span>     
0765     <span class="keyword">else</span>        
0766         <span class="keyword">if</span> ~InvtypeIsOK
0767             helpdlg({<span class="string">'function: runInversionJoint'</span>,<span class="string">'Perform standard multi-exponential inversion first.'</span>,<span class="keyword">...</span>
0768             <span class="string">'For ''fixed'' and ''shape'' you need a RTD!'</span>},<span class="string">'No RTD'</span>);
0769         <span class="keyword">end</span>
0770         <span class="keyword">if</span> ~GatetypeIsOK
0771             helpdlg({<span class="string">'function: runInversionJoint'</span>,<span class="string">'Check your ''signal gating'' settings.'</span>,<span class="keyword">...</span>
0772             <span class="string">'All signals need to have the same gating.'</span>},<span class="string">'Wrong gating'</span>);
0773         <span class="keyword">end</span>
0774     <span class="keyword">end</span>
0775 <span class="keyword">else</span>
0776     helpdlg({<span class="string">'function: runInversionJoint'</span>,<span class="string">'Perform standard inversion first.'</span>,<span class="keyword">...</span>
0777         <span class="string">'For ''fixed'' and ''shape'' you need a RTD!'</span>},<span class="string">'No Data'</span>);
0778 <span class="keyword">end</span>
0779 
0780 <span class="comment">%% at the end, no matter what reset the RUN button</span>
0781 set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'&lt;HTML&gt;&lt;u&gt;R&lt;/u&gt;UN'</span>,<span class="keyword">...</span>
0782     <span class="string">'BackgroundColor'</span>,<span class="string">'g'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,<span class="string">'Callback'</span>,@<a href="../../../nucleus/callbacks/push/onPushRun.html" class="code" title="function onPushRun(src,~)">onPushRun</a>);
0783 setappdata(fig,<span class="string">'gui'</span>,gui);
0784 
0785 <span class="keyword">end</span>
0786 
0787 <span class="comment">%------------- END OF CODE --------------</span>
0788 
0789 <span class="comment">%% License:</span>
0790 <span class="comment">% MIT License</span>
0791 <span class="comment">%</span>
0792 <span class="comment">% Copyright (c) 2018 Thomas Hiller</span>
0793 <span class="comment">%</span>
0794 <span class="comment">% Permission is hereby granted, free of charge, to any person obtaining a copy</span>
0795 <span class="comment">% of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
0796 <span class="comment">% in the Software without restriction, including without limitation the rights</span>
0797 <span class="comment">% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
0798 <span class="comment">% copies of the Software, and to permit persons to whom the Software is</span>
0799 <span class="comment">% furnished to do so, subject to the following conditions:</span>
0800 <span class="comment">%</span>
0801 <span class="comment">% The above copyright notice and this permission notice shall be included in all</span>
0802 <span class="comment">% copies or substantial portions of the Software.</span>
0803 <span class="comment">%</span>
0804 <span class="comment">% THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
0805 <span class="comment">% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
0806 <span class="comment">% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
0807 <span class="comment">% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
0808 <span class="comment">% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
0809 <span class="comment">% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
0810 <span class="comment">% SOFTWARE.</span></pre></div>
<hr><address>Generated by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>