<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of runInversionJoint</title>
  <meta name="keywords" content="runInversionJoint">
  <meta name="description" content=" controls the joint inversion process to infer a pore size">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # nucleus --><!-- # functions --><!-- menu.html interface -->
<h1>runInversionJoint
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong> controls the joint inversion process to infer a pore size</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function runInversionJoint </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">runInversionJoint controls the joint inversion process to infer a pore size
distribution (PSD) from NMR and CPS data

 Syntax:
       runInversionJoint

 Inputs:
       none

 Outputs:
       none

 Example:
       runInversionJoint

 Other m-files required:
       checkIfInversionExists
       clearSingleAxis
       displayStatusText
       fcn_JointInvfixed
       fcn_JointInvfree
       fcn_JointInvshape
       getChi2
       getLambdaFromRMS
       getConstants
       getCornerNMRparameter
       getGeometryParameter
       getPartialSaturationMatrix    
       getSaturationFromPressureBatch
       onPushRun
       onPushShowHide
       onPushStop
       removeInversionFields    
       updateInfo
       updatePlotsJointInversion    
       updatePlotsLcurve</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../nucleus/callbacks/push/onPushRun.html" class="code" title="function onPushRun(src,~)">onPushRun</a>	 handles the callbacks to all RUN push buttons in both GUIs and</li><li><a href="../../../nucleus/callbacks/push/onPushShowHide.html" class="code" title="function onPushShowHide(src,~)">onPushShowHide</a>	 shows/hides the INFO column on the right side of NUCLEUSinv</li><li><a href="../../../nucleus/callbacks/push/onPushStop.html" class="code" title="function onPushStop(src,~)">onPushStop</a>	 recognizes that a STOP push button was pressed and resets the</li><li><a href="checkIfInversionExists.html" class="code" title="function [foundINV,N] = checkIfInversionExists(INVdata)">checkIfInversionExists</a>	 checks if any inversion result is stored inside</li><li><a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>	 clears an individual axis</li><li><a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>	 shows status information either in the GUI or on the</li><li><a href="removeInversionFields.html" class="code" title="function data = removeInversionFields(data)">removeInversionFields</a>	 deletes all inversion result fields from NUCLEUSinv</li><li><a href="updateInfo.html" class="code" title="function updateInfo(src,~) %#ok<INUSD>">updateInfo</a>	 updates the information shown in all information list boxes</li><li><a href="updatePlotsJointInversion.html" class="code" title="function updatePlotsJointInversion">updatePlotsJointInversion</a>	 plots the joint-inversion results in NUCLEUSinv</li><li><a href="updatePlotsLcurve.html" class="code" title="function updatePlotsLcurve">updatePlotsLcurve</a>	 plots the results of the L-curve calculation</li><li><a href="../../../nucleus/functions/inversion/fcn_JointInvfixed.html" class="code" title="function [F,varargout] = fcn_JointInvfixed(X,iparam)">fcn_JointInvfixed</a>	 performs the "fixed" joint inversion using the RTD of</li><li><a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>	 jointly estimates the pore size distribution and surface</li><li><a href="../../../nucleus/functions/inversion/fcn_JointInvshape.html" class="code" title="function [F,varargout] = fcn_JointInvshape(X,iparam)">fcn_JointInvshape</a>	 performs the "shape" joint inversion using the RTD of</li><li><a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>	 the chi2 of a NMR fit (noise weighted error quality)</li><li><a href="../../../nucleus/functions/inversion/getLambdaFromLCurve.html" class="code" title="function index = getLambdaFromLCurve(rho,eta,plotit)">getLambdaFromLCurve</a>	 estimates the regularization parameter lambda according</li><li><a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>	 provides some physical constants to the forward calculation</li><li><a href="../../../nucleus/functions/modeling/getCornerNMRparameter.html" class="code" title="function out = getCornerNMRparameter(geometry,SatData,indt,imbdrain)">getCornerNMRparameter</a>	 calculates corner parameters (amplitude surface to</li><li><a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>	 calculates geometric parameters for the three possible</li><li><a href="../../../nucleus/functions/modeling/getPartialSaturationMatrix.html" class="code" title="function IPS = getPartialSaturationMatrix(SatData,indt,imbdrain)">getPartialSaturationMatrix</a>	 calculates the partial saturation matrix to be</li><li><a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../nucleus/callbacks/push/onPushRun.html" class="code" title="function onPushRun(src,~)">onPushRun</a>	 handles the callbacks to all RUN push buttons in both GUIs and</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function runInversionJoint</a>
0002 <span class="comment">%runInversionJoint controls the joint inversion process to infer a pore size</span>
0003 <span class="comment">%distribution (PSD) from NMR and CPS data</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Syntax:</span>
0006 <span class="comment">%       runInversionJoint</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Inputs:</span>
0009 <span class="comment">%       none</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Outputs:</span>
0012 <span class="comment">%       none</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% Example:</span>
0015 <span class="comment">%       runInversionJoint</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% Other m-files required:</span>
0018 <span class="comment">%       checkIfInversionExists</span>
0019 <span class="comment">%       clearSingleAxis</span>
0020 <span class="comment">%       displayStatusText</span>
0021 <span class="comment">%       fcn_JointInvfixed</span>
0022 <span class="comment">%       fcn_JointInvfree</span>
0023 <span class="comment">%       fcn_JointInvshape</span>
0024 <span class="comment">%       getChi2</span>
0025 <span class="comment">%       getLambdaFromRMS</span>
0026 <span class="comment">%       getConstants</span>
0027 <span class="comment">%       getCornerNMRparameter</span>
0028 <span class="comment">%       getGeometryParameter</span>
0029 <span class="comment">%       getPartialSaturationMatrix</span>
0030 <span class="comment">%       getSaturationFromPressureBatch</span>
0031 <span class="comment">%       onPushRun</span>
0032 <span class="comment">%       onPushShowHide</span>
0033 <span class="comment">%       onPushStop</span>
0034 <span class="comment">%       removeInversionFields</span>
0035 <span class="comment">%       updateInfo</span>
0036 <span class="comment">%       updatePlotsJointInversion</span>
0037 <span class="comment">%       updatePlotsLcurve</span>
0038 
0039 <span class="comment">%</span>
0040 <span class="comment">% Subfunctions:</span>
0041 <span class="comment">%       none</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% MAT-files required:</span>
0044 <span class="comment">%       none</span>
0045 <span class="comment">%</span>
0046 <span class="comment">% See also: NUCLEUSinv</span>
0047 <span class="comment">% Author: see AUTHORS.md</span>
0048 <span class="comment">% email: see AUTHORS.md</span>
0049 <span class="comment">% License: MIT License (at end)</span>
0050 
0051 <span class="comment">%------------- BEGIN CODE --------------</span>
0052 
0053 <span class="comment">%% get GUI handle and data</span>
0054 fig = findobj(<span class="string">'Tag'</span>,<span class="string">'INV'</span>);
0055 gui = getappdata(fig,<span class="string">'gui'</span>);
0056 data = getappdata(fig,<span class="string">'data'</span>);
0057 INVdata = getappdata(fig,<span class="string">'INVdata'</span>);
0058 
0059 <span class="comment">% check if there is any inversion results at all</span>
0060 foundINV = <a href="checkIfInversionExists.html" class="code" title="function [foundINV,N] = checkIfInversionExists(INVdata)">checkIfInversionExists</a>(INVdata);
0061 
0062 <span class="comment">%% if yes continue</span>
0063 <span class="keyword">if</span> foundINV    
0064     <span class="comment">% check which signals have been inverted before</span>
0065     <span class="comment">% (E0 is needed for Sat-normalization)</span>
0066     nINV = size(INVdata,1);
0067     E0 = zeros(nINV,1);
0068     c = 0;
0069     <span class="keyword">for</span> i = 1:nINV
0070         <span class="keyword">if</span> isstruct(INVdata{i})
0071             c = c + 1;
0072             E0(i,1) = sum(INVdata{i}.results.invstd.E0);
0073             invlevels(c) = i; <span class="comment">%#ok&lt;*AGROW&gt;</span>
0074             invtype{c} = INVdata{i}.invstd.invtype;
0075             gatetype{c} = INVdata{i}.results.nmrproc.gatetype;
0076         <span class="keyword">end</span>
0077     <span class="keyword">end</span>    
0078     <span class="comment">% for &quot;fixed&quot; and &quot;shape&quot; inversion a RTD is needed</span>
0079     InvtypeIsOK = false;
0080     <span class="keyword">switch</span> data.invjoint.invtype
0081         <span class="keyword">case</span> {<span class="string">'fixed'</span>,<span class="string">'shape'</span>}
0082             <span class="keyword">switch</span> invtype{1}
0083                 <span class="keyword">case</span> {<span class="string">'LU'</span>,<span class="string">'NNLS'</span>}
0084                     InvtypeIsOK = true;
0085                 <span class="keyword">otherwise</span>
0086                     <span class="comment">% nothing to do</span>
0087             <span class="keyword">end</span>
0088         <span class="keyword">otherwise</span>
0089             InvtypeIsOK = true;
0090     <span class="keyword">end</span>
0091     <span class="comment">% check if the gatetype is for all signals the same</span>
0092     GatetypeIsOK = false;
0093     <span class="keyword">if</span> numel(unique(gatetype)) == 1
0094         GatetypeIsOK = true;
0095     <span class="keyword">end</span>
0096     
0097     <span class="comment">% the pressure / saturation data</span>
0098     table = data.pressure.table;
0099     uselevel = cell2mat(table(:,1));
0100     tablelevels = 1:size(table,1);
0101     tablelevels = tablelevels(uselevel);
0102     
0103     <span class="comment">% get the union of inverted signals and check marks in the CPS table</span>
0104     [isin,levels] = ismember(invlevels,tablelevels);
0105     levels = tablelevels(levels(isin));
0106     
0107     <span class="comment">% at least the first one should be there and the inversion type should</span>
0108     <span class="comment">% be okay</span>
0109     <span class="keyword">if</span> any(levels==1) &amp;&amp; InvtypeIsOK &amp;&amp; GatetypeIsOK
0110         <span class="comment">% the pressure / saturation data</span>
0111         table = data.pressure.table;
0112         p0 = cell2mat(table(:,2));
0113         S0 = cell2mat(table(:,3));
0114         SatImbDrain = cell2mat(table(:,4))';
0115         <span class="comment">% used for inversion</span>
0116         p = p0(levels);
0117         S = S0(levels);
0118         SatImbDrain = SatImbDrain(levels);
0119         
0120         <span class="comment">% the NMR signals used for inversion</span>
0121         <span class="keyword">for</span> i = 1:numel(levels)
0122             idata.nmr{levels(i)}.name = data.import.NMR.filesShort{levels(i)};
0123             idata.nmr{levels(i)}.t0 = INVdata{levels(i)}.results.nmrproc.t;
0124             idata.nmr{levels(i)}.g0 = S(i).*<span class="keyword">...</span>
0125                 (INVdata{levels(i)}.results.nmrproc.s./E0(levels(i)));
0126             idata.nmr{levels(i)}.t = INVdata{levels(i)}.results.nmrproc.t;
0127             idata.nmr{levels(i)}.g = S(i).*<span class="keyword">...</span>
0128                 (INVdata{levels(i)}.results.nmrproc.s./E0(levels(i)));
0129             idata.nmr{levels(i)}.N = INVdata{levels(i)}.results.nmrproc.N;
0130             idata.nmr{levels(i)}.noise = S(i).*<span class="keyword">...</span>
0131                 (INVdata{levels(i)}.results.nmrproc.noise./E0(levels(i)));
0132             idata.nmr{levels(i)}.e = idata.nmr{levels(i)}.noise./<span class="keyword">...</span>
0133                 sqrt(idata.nmr{levels(i)}.N);
0134             
0135             <span class="comment">% switch depending on inversion method</span>
0136             <span class="keyword">switch</span> data.invjoint.invtype
0137                 <span class="keyword">case</span> <span class="string">'free'</span>
0138                     <span class="comment">% T1 or T2 data?</span>
0139                     <span class="keyword">if</span> levels(i) == 1
0140                         T1T2flag = INVdata{levels(i)}.results.nmrproc.T1T2;
0141                         T1IRfac = INVdata{levels(i)}.results.nmrproc.T1IRfac;
0142                     <span class="keyword">end</span>
0143                 <span class="keyword">case</span> {<span class="string">'fixed'</span>,<span class="string">'shape'</span>}
0144                     <span class="keyword">if</span> levels(i) == 1
0145                         <span class="comment">% full saturation RTD</span>
0146                         fullsat.T = INVdata{levels(i)}.results.invstd.T1T2me;
0147                         fullsat.F = S(i).*<span class="keyword">...</span>
0148                             (INVdata{levels(i)}.results.invstd.T1T2f./<span class="keyword">...</span>
0149                             sum(INVdata{levels(i)}.results.invstd.T1T2f));
0150                         <span class="comment">% T1 or T2 data?</span>
0151                         T1T2flag = INVdata{levels(i)}.results.nmrproc.T1T2;
0152                         T1IRfac = INVdata{levels(i)}.results.nmrproc.T1IRfac;
0153                     <span class="keyword">end</span>
0154             <span class="keyword">end</span>
0155         <span class="keyword">end</span>
0156         
0157         <span class="comment">% stack all NMR signals into one long vector</span>
0158         c = 0;
0159         indt = zeros(size(levels));
0160         <span class="keyword">for</span> i = 1:numel(levels)
0161             c = c + 1;
0162             <span class="keyword">if</span> c == 1
0163                 t = idata.nmr{levels(i)}.t';
0164                 g = idata.nmr{levels(i)}.g';
0165                 e = idata.nmr{levels(i)}.e';
0166                 N = idata.nmr{levels(i)}.N';
0167             <span class="keyword">else</span>
0168                 t = [t idata.nmr{levels(i)}.t'];
0169                 g = [g idata.nmr{levels(i)}.g'];
0170                 e = [e idata.nmr{levels(i)}.e'];
0171                 N = [N idata.nmr{levels(i)}.N'];
0172             <span class="keyword">end</span>
0173             indt(c) = length(idata.nmr{levels(i)}.t);
0174         <span class="keyword">end</span>
0175         
0176         <span class="comment">% create the error weighing matrix</span>
0177         <span class="keyword">if</span> strcmp(unique(gatetype),<span class="string">'log'</span>) || strcmp(unique(gatetype),<span class="string">'lin'</span>)
0178             W = diag(e);
0179             useW = true;
0180         <span class="keyword">else</span>
0181             useW = false;
0182         <span class="keyword">end</span>
0183         
0184         <span class="comment">% inversion output on the command line</span>
0185         <span class="keyword">switch</span> data.info.InvInfo
0186             <span class="keyword">case</span> <span class="string">'on'</span>
0187                 info = <span class="string">'iter'</span>;
0188             <span class="keyword">case</span> <span class="string">'off'</span>
0189                 info = <span class="string">'off'</span>;
0190         <span class="keyword">end</span>
0191         
0192         <span class="comment">% switch depending on inversion method</span>
0193         <span class="keyword">switch</span> data.invjoint.invtype            
0194             <span class="keyword">case</span> <span class="string">'free'</span>
0195                 <span class="comment">% radii distribution</span>
0196                 r_start = log10(data.invjoint.radii(1));
0197                 r_end = log10(data.invjoint.radii(2));
0198                 r = logspace(r_start,r_end,(r_end-r_start)*data.invjoint.Nradii);
0199                 
0200                 <span class="comment">% inversion geometry</span>
0201                 igeom.type = data.invjoint.geometry_type;
0202                 igeom.angles = [data.invjoint.alpha data.invjoint.beta data.invjoint.gamma];
0203                 igeom.polyN = data.invjoint.polyN;
0204                 igeom.radius = r';
0205                 igeom = <a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>(igeom);
0206                 
0207                 <span class="comment">% saturation for the inversion model</span>
0208                 ipsddata.r = igeom.radius';
0209                 ipsddata.psd = ones(size(ipsddata.r));
0210                 <span class="comment">% wait-bar option</span>
0211                 wbopts.show = false;
0212                 wbopts.tag = <span class="string">'INV'</span>;
0213                 iSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(igeom,p,ipsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0214                 IPS = <a href="../../../nucleus/functions/modeling/getPartialSaturationMatrix.html" class="code" title="function IPS = getPartialSaturationMatrix(SatData,indt,imbdrain)">getPartialSaturationMatrix</a>(iSAT,indt,SatImbDrain);
0215                 <span class="comment">% get the amplitudes and surface to volume ratios for all shapes</span>
0216                 SVdata = <a href="../../../nucleus/functions/modeling/getCornerNMRparameter.html" class="code" title="function out = getCornerNMRparameter(geometry,SatData,indt,imbdrain)">getCornerNMRparameter</a>(igeom,iSAT,indt,SatImbDrain);
0217                 SVdata.TT = repmat(t',[1 length(SVdata.SVF)]);
0218                 
0219                 <span class="comment">% derivative matrix</span>
0220                 L = get_l(length(ipsddata.r),data.invjoint.Lorder);
0221                 
0222                 <span class="comment">% switch depending on regularization method</span>
0223                 <span class="keyword">switch</span> data.invjoint.regtype                    
0224                     <span class="keyword">case</span> <span class="string">'lcurve'</span>
0225                         <span class="comment">% clear axes</span>
0226                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.all);
0227                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.rtd);
0228                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.psd);
0229                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.psdj);
0230                         <a href="clearSingleAxis.html" class="code" title="function clearSingleAxis(axh)">clearSingleAxis</a>(gui.axes_handles.cps);
0231                         
0232                         <span class="comment">% make the RUN button a STOP button</span>
0233                         <span class="comment">% set &quot;UserData&quot; to 1 to catch a STOP button event</span>
0234                         set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'STOP'</span>,<span class="keyword">...</span>
0235                             <span class="string">'BackGroundColor'</span>,<span class="string">'r'</span>,<span class="string">'UserData'</span>,1,<span class="string">'Callback'</span>,@<a href="../../../nucleus/callbacks/push/onPushStop.html" class="code" title="function onPushStop(src,~)">onPushStop</a>);
0236                         
0237                         <span class="comment">% no command line output during l-curve calculation</span>
0238                         info = <span class="string">'off'</span>;
0239                         
0240                         <span class="comment">% lambda range and initialization of output variables</span>
0241                         lambda_range = logspace(log10(data.invjoint.lambdaR(1)),<span class="keyword">...</span>
0242                             log10(data.invjoint.lambdaR(2)),data.invjoint.NlambdaR);
0243                         RMS = zeros(size(lambda_range));
0244                         XN = zeros(size(lambda_range));
0245                         RN = zeros(size(lambda_range));
0246                         
0247                         <span class="comment">% status bar information</span>
0248                         infostring = <span class="string">'L-Curve calculation ... '</span>;
0249                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0250                         
0251                         <span class="comment">% wait-bar option</span>
0252                         wbopts.show = true;
0253                         wbopts.tag = <span class="string">'INV'</span>;
0254                         <span class="keyword">if</span> wbopts.show
0255                             hwb = waitbar(0,<span class="string">'processing ...'</span>,<span class="string">'Name'</span>,<span class="string">'L-Curve calculation'</span>,<span class="string">'Visible'</span>,<span class="string">'off'</span>);
0256                             steps = length(lambda_range);
0257                             fig = findobj(<span class="string">'Tag'</span>,wbopts.tag);
0258                             <span class="keyword">if</span> ~isempty(fig)
0259                                 posf = get(fig,<span class="string">'Position'</span>);
0260                                 set(hwb,<span class="string">'Units'</span>,<span class="string">'Pixel'</span>)
0261                                 posw = get(hwb,<span class="string">'Position'</span>);
0262                                 set(hwb,<span class="string">'Position'</span>,[posf(1)+posf(3)/2-posw(3)/2 posf(2)+posf(4)/2-posw(4)/2 posw(3:4)]);
0263                             <span class="keyword">end</span>
0264                             set(hwb,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
0265                         <span class="keyword">end</span>
0266                         
0267                         <span class="comment">% the L-curve calculation</span>
0268                         <span class="keyword">for</span> i = 1:length(lambda_range)
0269                             <span class="comment">% check if the STOP button was pressed</span>
0270                             <span class="comment">% if &quot;UserData&quot; is 1 STOP was not pressed -&gt; continue</span>
0271                             <span class="keyword">if</span> get(gui.push_handles.invjoint_run,<span class="string">'UserData'</span>) == 1
0272                                 
0273                                 iparam.t = t;
0274                                 iparam.g = g;
0275                                 <span class="keyword">if</span> useW
0276                                     iparam.W = W;
0277                                 <span class="keyword">end</span>
0278                                 iparam.Tb = data.invstd.Tbulk;
0279                                 iparam.Td = data.invstd.Tdiff;
0280                                 iparam.T1T2 = T1T2flag;
0281                                 iparam.T1IRfac = T1IRfac;
0282                                 iparam.L = L;
0283                                 iparam.lambda = lambda_range(i);
0284                                 iparam.igeom = igeom;
0285                                 iparam.IPS = IPS;
0286                                 iparam.SVdata = SVdata;
0287                                 iparam.SatImbDrain = SatImbDrain;
0288                                 
0289                                 <span class="comment">% start values and bounds</span>
0290                                 rhostart = log10(data.invjoint.rhostart/1e6);
0291                                 rhobounds = log10(data.invjoint.rhobounds/1e6);
0292                                 x0 = [zeros(size(igeom.radius))' rhostart];
0293                                 lb = [zeros(size(igeom.radius))' rhobounds(1)];
0294                                 ub = [ones(size(igeom.radius))' rhobounds(2)];
0295                                 
0296                                 options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="keyword">...</span>
0297                                     <span class="string">'Jacobian'</span>,<span class="string">'on'</span>,<span class="string">'DerivativeCheck'</span>,<span class="string">'off'</span>,<span class="string">'FinDiffType'</span>,<span class="string">'central'</span>,<span class="keyword">...</span>
0298                                     <span class="string">'Algorithm'</span>,<span class="string">'levenberg-marquardt'</span>,<span class="keyword">...</span>
0299                                     <span class="string">'MaxIter'</span>,1000);
0300                                 
0301                                 [X,~,~,~] = lsqnonlin(@(X)<a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam),x0,lb,ub,options);
0302                                 [~,~,ig,~] = <a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam);
0303                                 
0304                                 <span class="keyword">if</span> useW
0305                                     <span class="comment">% normalize the fit because the signal was error</span>
0306                                     <span class="comment">% weighted for the inversion</span>
0307                                     e = diag(iparam.W);
0308                                     einv = 1./e;
0309                                     Winv = diag(einv);
0310                                     ig = Winv * ig;
0311                                 <span class="keyword">end</span>
0312                         
0313                                 residual = ig - g';
0314                                 iF = X(1:length(X)-1);
0315                                 
0316                                 <span class="comment">% output data</span>
0317                                 <span class="comment">% get RMS and X^2</span>
0318                                 <span class="keyword">if</span> useW
0319                                     <span class="comment">% weighted RMS error</span>
0320                                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0321                                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0322                                     RMS(i) = sqrt (sum(N'.*(residual).^2) / length(residual));
0323                                     <span class="comment">% X2 estimate</span>
0324                                     CHI2(i) = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0325                                 <span class="keyword">else</span>
0326                                     <span class="comment">% RMS error</span>
0327                                     RMS(i) = sqrt( sum(residual.^2) / length(residual) );
0328                                     <span class="comment">% X2 estimate</span>
0329                                     CHI2(i) = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0330                                 <span class="keyword">end</span>
0331                                 <span class="comment">% error norm and model norm</span>
0332                                 RN(i) = norm(residual,2);
0333                                 XN(i) = norm(L*iF',2);
0334                                 <span class="comment">% wait-bar update</span>
0335                                 <span class="keyword">if</span> wbopts.show
0336                                     waitbar(i / steps,hwb,[<span class="string">'processing ...'</span>,num2str(i),<span class="string">' / '</span>,num2str(steps),<span class="string">' lambda steps'</span>]);
0337                                 <span class="keyword">end</span>
0338                             <span class="keyword">end</span>
0339                         <span class="keyword">end</span>                        
0340                         <span class="comment">% delete the wait-bar</span>
0341                         <span class="keyword">if</span> wbopts.show
0342                             delete(hwb);
0343                         <span class="keyword">end</span>
0344                         
0345                         <span class="comment">% check if the STOP button was pressed</span>
0346                         <span class="comment">% if &quot;UserData&quot; is 1 STOP was not pressed -&gt; save data</span>
0347                         <span class="keyword">if</span> get(gui.push_handles.invjoint_run,<span class="string">'UserData'</span>) == 1
0348                             lc.lambda = lambda_range;
0349                             lc.RMS = RMS;
0350                             lc.RN = RN;
0351                             lc.XN = XN;
0352                             <span class="comment">% get optimal lambda</span>
0353 <span class="comment">%                             lc.index = getLambdaFromRMS(lc.lambda,lc.RMS,0);</span>
0354                             lc.index = <a href="../../../nucleus/functions/inversion/getLambdaFromLCurve.html" class="code" title="function index = getLambdaFromLCurve(rho,eta,plotit)">getLambdaFromLCurve</a>(RN,XN,0);
0355                             data.results.lcurve = lc;
0356                             <span class="comment">% update GUI data</span>
0357                             setappdata(fig,<span class="string">'data'</span>,data);
0358                             <span class="comment">% update L-curve plots</span>
0359                             <a href="updatePlotsLcurve.html" class="code" title="function updatePlotsLcurve">updatePlotsLcurve</a>;
0360                             <span class="comment">% status bar information</span>
0361                             <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">' done'</span>]);
0362                             <span class="comment">% set focus on results</span>
0363                             set(gui.plots.DistPanel,<span class="string">'Selection'</span>,1);
0364                         <span class="keyword">else</span>
0365                             <span class="comment">% status bar information</span>
0366                             <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">' was canceled'</span>]);
0367                             <span class="comment">% remove temporary data fields</span>
0368                             data = <a href="removeInversionFields.html" class="code" title="function data = removeInversionFields(data)">removeInversionFields</a>(data);
0369                         <span class="keyword">end</span>
0370                         
0371                     <span class="keyword">case</span> <span class="string">'manual'</span>
0372                         <span class="comment">% disable the RUN button to indicate a running inversion</span>
0373                         set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'RUNNING ...'</span>,<span class="keyword">...</span>
0374                             <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);
0375 
0376                         <span class="comment">% inversion parameter</span>
0377                         iparam.t = t;
0378                         iparam.g = g;
0379                         <span class="keyword">if</span> useW
0380                             iparam.W = W;
0381                         <span class="keyword">end</span>
0382                         iparam.Tb = data.invstd.Tbulk;
0383                         iparam.Td = data.invstd.Tdiff;
0384                         iparam.T1T2 = T1T2flag;
0385                         iparam.T1IRfac = T1IRfac;
0386                         iparam.L = L;
0387                         iparam.lambda = data.invjoint.lambda;
0388                         iparam.igeom = igeom;
0389                         iparam.IPS = IPS;
0390                         iparam.SVdata = SVdata;
0391                         iparam.SatImbDrain = SatImbDrain;
0392                         
0393                         <span class="comment">% start values and bounds</span>
0394                         rhostart = log10(data.invjoint.rhostart/1e6);
0395                         rhobounds = log10(data.invjoint.rhobounds/1e6);
0396                         x0 = [zeros(size(igeom.radius))' rhostart];
0397                         lb = [zeros(size(igeom.radius))' rhobounds(1)];
0398                         ub = [ones(size(igeom.radius))' rhobounds(2)];
0399                         
0400                         <span class="comment">% status bar information</span>
0401                         infostring = <span class="string">'Joint Inversion (free) using ''lsqnonlin'' ... '</span>;
0402                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0403                         
0404                         <span class="comment">% optimization settings</span>
0405                         options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="keyword">...</span>
0406                             <span class="string">'Jacobian'</span>,<span class="string">'on'</span>,<span class="string">'DerivativeCheck'</span>,<span class="string">'off'</span>,<span class="string">'FinDiffType'</span>,<span class="string">'central'</span>,<span class="keyword">...</span>
0407                             <span class="string">'Algorithm'</span>,<span class="string">'levenberg-marquardt'</span>,<span class="keyword">...</span>
0408                             <span class="string">'MaxIter'</span>,1000);
0409                         [X,~,~,exitflag] = lsqnonlin(@(X)<a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam),x0,lb,ub,options);
0410                         
0411                         <span class="comment">% status bar information</span>
0412                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0413                         <span class="comment">% get the final fit</span>
0414                         [~,~,ig,KK] = <a href="../../../nucleus/functions/inversion/fcn_JointInvfree.html" class="code" title="function [F,J,ig,XX] = fcn_JointInvfree(X,iparam)">fcn_JointInvfree</a>(X,iparam);
0415                         
0416                         <span class="keyword">if</span> useW
0417                             <span class="comment">% normalize the fit because the signal was error</span>
0418                             <span class="comment">% weighted for the inversion</span>
0419                             e = diag(iparam.W);
0420                             einv = 1./e;
0421                             Winv = diag(einv);
0422                             ig = Winv * ig;
0423                         <span class="keyword">end</span>
0424                 
0425                         <span class="comment">% the inverted surface relaxivity and PSD</span>
0426                         iF = X(1:length(X)-1);
0427                         irho = 10^X(length(X));
0428                         <span class="comment">% inversion output</span>
0429                         data.results.invjoint.p0 = p0;
0430                         data.results.invjoint.S0 = S0;
0431                         data.results.invjoint.levels = levels;
0432                         data.results.invjoint.T1T2 = T1T2flag;
0433                         data.results.invjoint.T1IRfac = T1IRfac;
0434                         data.results.invjoint.x0 = x0;
0435                         data.results.invjoint.lb = lb;
0436                         data.results.invjoint.ub = ub;
0437                         data.results.invjoint.iparam = iparam;
0438                         data.results.invjoint.iGEOM = igeom;
0439                         data.results.invjoint.iSAT = iSAT;
0440                         data.results.invjoint.iF = iF';
0441                         data.results.invjoint.irho = irho;
0442                         data.results.invjoint.ig = ig;
0443                         data.results.invjoint.XX = KK;
0444                         data.results.invjoint.errnorm = norm((ig - g')).^2;
0445                         data.results.invjoint.residual = ig - g';
0446                         data.results.invjoint.exitflag = exitflag;
0447                         
0448                         <span class="comment">% get RMS and X^2</span>
0449                         residual = data.results.invjoint.residual;
0450                         <span class="keyword">if</span> useW
0451                             <span class="comment">% weighted RMS error</span>
0452                             <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0453                             <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0454                             data.results.invjoint.rms = sqrt (sum(N'.*(residual).^2) / length(residual));
0455                             <span class="comment">% X2 estimate</span>
0456                             data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0457                         <span class="keyword">else</span>
0458                             <span class="comment">% RMS error</span>
0459                             data.results.invjoint.rms = sqrt( sum(residual.^2) / length(residual) );
0460                             <span class="comment">% X2 estimate</span>
0461                             data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0462                         <span class="keyword">end</span>
0463                                                 
0464                         <span class="comment">% predict CPS curves for the final model</span>
0465                         infostring = <span class="string">'calculate CPS curve ... '</span>;
0466                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0467                         ppsddata.r = igeom.radius';
0468                         ppsddata.psd = data.results.invjoint.iF'./sum(data.results.invjoint.iF);
0469                         <span class="keyword">if</span> min(p) == 0
0470                             p_tmp = logspace(floor(log10(min(p(p&gt;0)))-2),ceil(log10(max(p)))+2,150);
0471                         <span class="keyword">else</span>
0472                             p_tmp = logspace(floor(log10(min(p)/2)),ceil(log10(max(p)))+2,150);
0473                         <span class="keyword">end</span>
0474                         <span class="comment">% waitbar option</span>
0475                         wbopts.show = true;
0476                         wbopts.tag = <span class="string">'INV'</span>;
0477                         pSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(igeom,p_tmp,ppsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0478                         <span class="comment">% save</span>
0479                         data.results.invjoint.pSAT = pSAT;
0480                         <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]); 
0481                 <span class="keyword">end</span>
0482                 
0483             <span class="keyword">case</span> <span class="string">'fixed'</span> <span class="comment">% only invert for rho</span>
0484                 <span class="comment">% disable the RUN button to indicate a running inversion</span>
0485                 set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'RUNNING ...'</span>,<span class="keyword">...</span>
0486                     <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);
0487                 
0488                 <span class="comment">% inversion geometry</span>
0489                 igeom.type = data.invjoint.geometry_type;
0490                 igeom.angles = [data.invjoint.alpha data.invjoint.beta data.invjoint.gamma];
0491                 igeom.polyN = data.invjoint.polyN;
0492                 igeom.radius = data.param.rho.*data.param.a.*fullsat.T; <span class="comment">% first guess</span>
0493                 igeom = <a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>(igeom);
0494                 
0495                 iparam.t = t;
0496                 iparam.g = g;
0497                 <span class="keyword">if</span> useW
0498                     iparam.W = W;
0499                 <span class="keyword">end</span>
0500                 iparam.indt = indt;
0501                 iparam.Tb = data.invstd.Tbulk;
0502                 iparam.Td = data.invstd.Tdiff;
0503                 iparam.T1T2 = T1T2flag;
0504                 iparam.T1IRfac = T1IRfac;
0505                 iparam.SatImbDrain = SatImbDrain;
0506                 iparam.p = p;
0507                 iparam.igeom = igeom;
0508                 iparam.x = fullsat.T';
0509                 iparam.f = fullsat.F';
0510                 
0511                 <span class="comment">% start values and bounds</span>
0512                 x0 = log10(data.invjoint.rhostart/1e6);
0513                 rhobounds = log10(data.invjoint.rhobounds/1e6);
0514                 lb = rhobounds(1);
0515                 ub = rhobounds(2);
0516                 
0517                 infostring = <span class="string">'Joint Inversion (fixed) using ''fminsearchbnd'' ... '</span>;
0518                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0519                 
0520                 options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="keyword">...</span>
0521                     <span class="string">'MaxFunEvals'</span>,300,<span class="string">'MaxIter'</span>,300);
0522                 X = fminsearchbnd(@(X) <a href="../../../nucleus/functions/inversion/fcn_JointInvfixed.html" class="code" title="function [F,varargout] = fcn_JointInvfixed(X,iparam)">fcn_JointInvfixed</a>(X,iparam),x0,lb,ub,options);
0523                 
0524                 [errnorm,ig,XX,iGEOM,iSAT] = <a href="../../../nucleus/functions/inversion/fcn_JointInvfixed.html" class="code" title="function [F,varargout] = fcn_JointInvfixed(X,iparam)">fcn_JointInvfixed</a>(X,iparam);
0525                 
0526                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0527                 
0528                 <span class="keyword">if</span> useW
0529                     <span class="comment">% normalize the fit because the signal was error</span>
0530                     <span class="comment">% weighted for the inversion</span>
0531                     e = diag(iparam.W);
0532                     einv = 1./e;
0533                     Winv = diag(einv);
0534                     ig = Winv * ig;
0535                 <span class="keyword">end</span>                
0536                 
0537                 <span class="comment">% inverted surface relaxivity</span>
0538                 irho = 10^X(1);
0539                 <span class="comment">% output data</span>
0540                 data.results.invjoint.p0 = p0;
0541                 data.results.invjoint.S0 = S0;
0542                 data.results.invjoint.levels = levels;
0543                 data.results.invjoint.T1T2 = T1T2flag;
0544                 data.results.invjoint.T1IRfac = T1IRfac;
0545                 data.results.invjoint.x0 = x0;
0546                 data.results.invjoint.lb = lb;
0547                 data.results.invjoint.ub = ub;
0548                 data.results.invjoint.iparam = iparam;
0549                 data.results.invjoint.iGEOM = iGEOM;
0550                 data.results.invjoint.iSAT = iSAT;
0551                 data.results.invjoint.iF = fullsat.F;
0552                 data.results.invjoint.irho = irho;
0553                 data.results.invjoint.ig = ig;
0554                 data.results.invjoint.XX = XX;
0555                 data.results.invjoint.errnorm = errnorm;
0556                 data.results.invjoint.residual = ig-g';
0557                 
0558                 <span class="comment">% get RMS and X^2</span>
0559                 residual = data.results.invjoint.residual;
0560                 <span class="keyword">if</span> useW
0561                     <span class="comment">% weighted RMS error</span>
0562                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0563                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0564                     data.results.invjoint.rms = sqrt (sum(N'.*(residual).^2) / length(residual));
0565                     <span class="comment">% X2 estimate</span>
0566                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0567                 <span class="keyword">else</span>
0568                     <span class="comment">% RMS error</span>
0569                     data.results.invjoint.rms = sqrt( sum(residual.^2) / length(residual) );
0570                     <span class="comment">% X2 estimate</span>
0571                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0572                 <span class="keyword">end</span>
0573                 
0574                 <span class="comment">% predict CPS curves from final model</span>
0575                 infostring = <span class="string">'calculate CPS curve ... '</span>;
0576                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0577                 ppsddata.r = iGEOM.radius';
0578                 ppsddata.psd = data.results.invjoint.iF'./sum(data.results.invjoint.iF);
0579                 <span class="keyword">if</span> min(p) == 0
0580                     p_tmp = logspace(floor(log10(min(p(p&gt;0)))-2),ceil(log10(max(p)))+2,200);
0581                 <span class="keyword">else</span>
0582                     p_tmp = logspace(floor(log10(min(p)/2)),ceil(log10(max(p)))+2,200);
0583                 <span class="keyword">end</span>
0584                 <span class="comment">% waitbar option</span>
0585                 wbopts.show = true;
0586                 wbopts.tag = <span class="string">'INV'</span>;
0587                 pSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(iGEOM,p_tmp,ppsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0588                 
0589                 data.results.invjoint.pSAT = pSAT;
0590                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0591                 
0592             <span class="keyword">case</span> <span class="string">'shape'</span> <span class="comment">% invert for rho and right angular shape</span>
0593                 <span class="comment">% disable the RUN button to indicate a running inversion</span>
0594                 set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'RUNNING ...'</span>,<span class="keyword">...</span>
0595                     <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);
0596                 
0597                 <span class="comment">% inversion geometry</span>
0598                 igeom.type = data.invjoint.geometry_type;
0599                 igeom.angles = [data.invjoint.alpha data.invjoint.beta data.invjoint.gamma];
0600                 igeom.polyN = data.invjoint.polyN;
0601                 igeom.radius = data.param.rho.*data.param.a.*fullsat.T; <span class="comment">% first guess</span>
0602                 igeom = <a href="../../../nucleus/functions/modeling/getGeometryParameter.html" class="code" title="function geom = getGeometryParameter(geom)">getGeometryParameter</a>(igeom);
0603                 
0604                 iparam.t = t;
0605                 iparam.g = g;
0606                 <span class="keyword">if</span> useW
0607                     iparam.W = W;
0608                 <span class="keyword">end</span>
0609                 iparam.indt = indt;
0610                 iparam.Tb = data.invstd.Tbulk;
0611                 iparam.Td = data.invstd.Tdiff;
0612                 iparam.T1T2 = T1T2flag;
0613                 iparam.T1IRfac = T1IRfac;
0614                 iparam.SatImbDrain = SatImbDrain;
0615                 iparam.p = p;
0616                 iparam.igeom = igeom;
0617                 iparam.x = fullsat.T';
0618                 iparam.f = fullsat.F';
0619                 
0620                 <span class="comment">% scale fit parameter between [0 1]</span>
0621                 <span class="comment">% x0 = [(log10(1e-6)+7)/3 data.invjoint.beta/45];</span>
0622                 <span class="comment">% lb = [(log10(1e-7)+7)/3 0.1/45];</span>
0623                 <span class="comment">% ub = [(log10(1e-4)+7)/3 45/45];</span>
0624                 <span class="comment">% old way</span>
0625                 x0 = [log10(data.invjoint.rhostart/1e6) data.invjoint.anglestart];
0626                 rhobounds = log10(data.invjoint.rhobounds/1e6);
0627                 lb = [rhobounds(1) 0.1];
0628                 ub = [rhobounds(2) 45];
0629                 
0630                 infostring = <span class="string">'Joint Inversion (shape) using ''fminsearchbnd'' ... '</span>;
0631                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0632                 options = optimset(<span class="string">'Display'</span>,<span class="string">'iter'</span>,<span class="string">'TolFun'</span>,1e-12,<span class="string">'TolX'</span>,1e-12,<span class="string">'MaxIter'</span>,500);
0633                 options.Algorithm = <span class="string">'levenberg-marquardt'</span>;
0634                 options.MaxFunEvals = 500;
0635                 options.DiffMinChange = 1;
0636                 
0637                 options = optimset(<span class="string">'Display'</span>,info,<span class="string">'TolFun'</span>,1e-9,<span class="string">'TolX'</span>,1e-9,<span class="keyword">...</span>
0638                     <span class="string">'MaxFunEvals'</span>,300,<span class="string">'MaxIter'</span>,300);
0639                 X = fminsearchbnd(@(X) <a href="../../../nucleus/functions/inversion/fcn_JointInvshape.html" class="code" title="function [F,varargout] = fcn_JointInvshape(X,iparam)">fcn_JointInvshape</a>(X,iparam),x0,lb,ub,options);
0640                 
0641                 [errnorm,ig,XX,iGEOM,iSAT] = <a href="../../../nucleus/functions/inversion/fcn_JointInvshape.html" class="code" title="function [F,varargout] = fcn_JointInvshape(X,iparam)">fcn_JointInvshape</a>(X,iparam);
0642                 
0643                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0644                 
0645                 <span class="keyword">if</span> useW
0646                     <span class="comment">% normalize the fit because the signal was error</span>
0647                     <span class="comment">% weighted for the inversion</span>
0648                     e = diag(iparam.W);
0649                     einv = 1./e;
0650                     Winv = diag(einv);
0651                     ig = Winv * ig;
0652                 <span class="keyword">end</span>
0653                 
0654                 irho = 10^X(1);
0655                 ibeta = X(2);
0656                 
0657                 data.results.invjoint.p0 = p0;
0658                 data.results.invjoint.S0 = S0;
0659                 data.results.invjoint.levels = levels;
0660                 data.results.invjoint.T1T2 = T1T2flag;
0661                 data.results.invjoint.T1IRfac = T1IRfac;
0662                 data.results.invjoint.x0 = x0;
0663                 data.results.invjoint.lb = lb;
0664                 data.results.invjoint.ub = ub;
0665                 data.results.invjoint.iparam = iparam;
0666                 data.results.invjoint.iGEOM = iGEOM;
0667                 data.results.invjoint.iSAT = iSAT;
0668                 data.results.invjoint.iF = fullsat.F;
0669                 data.results.invjoint.irho = irho;
0670                 data.results.invjoint.ibeta = ibeta;
0671                 data.results.invjoint.ig = ig;
0672                 data.results.invjoint.XX = XX;
0673                 data.results.invjoint.errnorm = errnorm;
0674                 data.results.invjoint.residual = ig-g';
0675                 
0676                 <span class="comment">% get RMS and X^2</span>
0677                 residual = data.results.invjoint.residual;
0678                 <span class="keyword">if</span> useW
0679                     <span class="comment">% weighted RMS error</span>
0680                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0681                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0682                     data.results.invjoint.rms = sqrt (sum(N'.*(residual).^2) / length(residual));
0683                     <span class="comment">% X2 estimate</span>
0684                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,e);
0685                 <span class="keyword">else</span>
0686                     <span class="comment">% RMS error</span>
0687                     data.results.invjoint.rms = sqrt( sum(residual.^2) / length(residual) );
0688                     <span class="comment">% X2 estimate</span>
0689                     data.results.invjoint.chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(g',ig,idata.nmr{levels(1)}.noise);
0690                 <span class="keyword">end</span>
0691                 
0692                 <span class="comment">% predict CPS curves from final model</span>
0693                 infostring = <span class="string">'calculate CPS curve ... '</span>;
0694                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,infostring);
0695                 ppsddata.r = iGEOM.radius';
0696                 ppsddata.psd = data.results.invjoint.iF'./sum(data.results.invjoint.iF);
0697                 <span class="keyword">if</span> min(p) == 0
0698                     p_tmp = logspace(floor(log10(min(p(p&gt;0)))-2),ceil(log10(max(p)))+2,150);
0699                 <span class="keyword">else</span>
0700                     p_tmp = logspace(floor(log10(min(p)/2)),ceil(log10(max(p)))+2,150);
0701                 <span class="keyword">end</span>
0702                 <span class="comment">% wait-bar option</span>
0703                 wbopts.show = true;
0704                 wbopts.tag = <span class="string">'INV'</span>;
0705                 pSAT = <a href="../../../nucleus/functions/modeling/getSaturationFromPressureBatch.html" class="code" title="function SAT = getSaturationFromPressureBatch(GEOM,pressure,inpsd,constants,wbopts)">getSaturationFromPressureBatch</a>(iGEOM,p_tmp,ppsddata,<a href="../../../nucleus/functions/modeling/getConstants.html" class="code" title="function constants = getConstants">getConstants</a>,wbopts);
0706                 
0707                 data.results.invjoint.pSAT = pSAT;
0708                 <a href="displayStatusText.html" class="code" title="function displayStatusText(gui,string)">displayStatusText</a>(gui,[infostring,<span class="string">'done'</span>]);
0709         <span class="keyword">end</span>
0710         
0711         <span class="comment">% if the regularization method was not L-curve then post process the</span>
0712         <span class="comment">% NMR data fits</span>
0713         <span class="keyword">if</span> ~strcmp(data.invjoint.regtype,<span class="string">'lcurve'</span>)
0714             <span class="comment">% get the individual NMR fits</span>
0715             <span class="keyword">for</span> i = 1:1:numel(levels)
0716                 idata.nmr{levels(i)}.fit_t = idata.nmr{levels(i)}.t;
0717                 <span class="keyword">if</span> i == 1
0718                     idata.nmr{levels(i)}.fit_g = ig(1:indt(1));
0719                 <span class="keyword">else</span>
0720                     idata.nmr{levels(i)}.fit_g = ig(sum(indt(1:i-1))+1:sum(indt(1:i-1))+indt(i));
0721                 <span class="keyword">end</span>
0722                 residual = idata.nmr{levels(i)}.fit_g - idata.nmr{levels(i)}.g;
0723                 
0724                 <span class="comment">% get RMS and X^2</span>
0725                 <span class="keyword">if</span> useW
0726                     <span class="comment">% weighted RMS error</span>
0727                     <span class="comment">% residual is weighted with the amount of echoes N per time gate</span>
0728                     <span class="comment">% NOTE: if &quot;N per gate&quot; is too large, the RMS estimation breaks down</span>
0729                     N = idata.nmr{levels(i)}.N;
0730                     rms = sqrt (sum(N.*(residual).^2) / length(residual));
0731                     <span class="comment">% X2 estimate</span>
0732                     chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(idata.nmr{levels(i)}.g,<span class="keyword">...</span>
0733                         idata.nmr{levels(i)}.fit_g,<span class="keyword">...</span>
0734                         idata.nmr{levels(i)}.e);
0735                 <span class="keyword">else</span>
0736                     <span class="comment">% RMS error</span>
0737                     rms = sqrt( sum(residual.^2) / length(residual) );
0738                     <span class="comment">% X2 estimate</span>
0739                     chi2 = <a href="../../../nucleus/functions/inversion/getChi2.html" class="code" title="function chi2 = getChi2(signal,fit,noise)">getChi2</a>(idata.nmr{levels(i)}.g,<span class="keyword">...</span>
0740                         idata.nmr{levels(i)}.fit_g,<span class="keyword">...</span>
0741                         idata.nmr{levels(i)}.noise);
0742                 <span class="keyword">end</span>
0743 
0744                 idata.nmr{levels(i)}.residual = residual;
0745                 idata.nmr{levels(i)}.rms = rms;
0746                 idata.nmr{levels(i)}.chi2 = chi2;
0747             <span class="keyword">end</span>
0748             <span class="comment">% save the GUI data</span>
0749             data.results.invjoint.idata = idata;
0750             setappdata(fig,<span class="string">'data'</span>,data);
0751             
0752             <span class="comment">% save the &quot;INVdata&quot;</span>
0753             <span class="keyword">for</span> i = 1:1:numel(levels)
0754                 INVdata{levels(i)}.invjoint = data.invjoint;
0755                 INVdata{levels(i)}.pressure = data.pressure;
0756                 INVdata{levels(i)}.results.invjoint = data.results.invjoint;
0757             <span class="keyword">end</span>
0758             setappdata(fig,<span class="string">'INVdata'</span>,INVdata);
0759             <span class="comment">% update the plots</span>
0760             <a href="updatePlotsJointInversion.html" class="code" title="function updatePlotsJointInversion">updatePlotsJointInversion</a>;
0761             <span class="comment">% update the INFO fields</span>
0762             <a href="updateInfo.html" class="code" title="function updateInfo(src,~) %#ok<INUSD>">updateInfo</a>(gui.plots.SignalPanel);            
0763             <span class="comment">% set focus on results</span>
0764             set(gui.plots.SignalPanel,<span class="string">'Selection'</span>,3);
0765             set(gui.plots.DistPanel,<span class="string">'Selection'</span>,3);
0766             <span class="comment">% open INFO field</span>
0767             set(gui.push_handles.info,<span class="string">'String'</span>,<span class="string">'&lt;'</span>);
0768             <a href="../../../nucleus/callbacks/push/onPushShowHide.html" class="code" title="function onPushShowHide(src,~)">onPushShowHide</a>(gui.push_handles.info);
0769             <span class="comment">% activate the ConductView GUI</span>
0770             set(gui.menu.extra_conduct,<span class="string">'Enable'</span>,<span class="string">'on'</span>);
0771         <span class="keyword">end</span>     
0772     <span class="keyword">else</span>        
0773         <span class="keyword">if</span> ~InvtypeIsOK
0774             helpdlg({<span class="string">'function: runInversionJoint'</span>,<span class="string">'Perform standard multi-exponential inversion first.'</span>,<span class="keyword">...</span>
0775             <span class="string">'For ''fixed'' and ''shape'' you need a RTD!'</span>},<span class="string">'No RTD'</span>);
0776         <span class="keyword">end</span>
0777         <span class="keyword">if</span> ~GatetypeIsOK
0778             helpdlg({<span class="string">'function: runInversionJoint'</span>,<span class="string">'Check your ''signal gating'' settings.'</span>,<span class="keyword">...</span>
0779             <span class="string">'All signals need to have the same gating.'</span>},<span class="string">'Wrong gating'</span>);
0780         <span class="keyword">end</span>
0781     <span class="keyword">end</span>
0782 <span class="keyword">else</span>
0783     helpdlg({<span class="string">'function: runInversionJoint'</span>,<span class="string">'Perform standard inversion first.'</span>,<span class="keyword">...</span>
0784         <span class="string">'For ''fixed'' and ''shape'' you need a RTD!'</span>},<span class="string">'No Data'</span>);
0785 <span class="keyword">end</span>
0786 
0787 <span class="comment">%% at the end, no matter what reset the RUN button</span>
0788 set(gui.push_handles.invjoint_run,<span class="string">'String'</span>,<span class="string">'&lt;HTML&gt;&lt;u&gt;R&lt;/u&gt;UN'</span>,<span class="keyword">...</span>
0789     <span class="string">'BackgroundColor'</span>,<span class="string">'g'</span>,<span class="string">'Enable'</span>,<span class="string">'on'</span>,<span class="string">'Callback'</span>,@<a href="../../../nucleus/callbacks/push/onPushRun.html" class="code" title="function onPushRun(src,~)">onPushRun</a>);
0790 setappdata(fig,<span class="string">'gui'</span>,gui);
0791 
0792 <span class="keyword">end</span>
0793 
0794 <span class="comment">%------------- END OF CODE --------------</span>
0795 
0796 <span class="comment">%% License:</span>
0797 <span class="comment">% MIT License</span>
0798 <span class="comment">%</span>
0799 <span class="comment">% Copyright (c) 2018 Thomas Hiller</span>
0800 <span class="comment">%</span>
0801 <span class="comment">% Permission is hereby granted, free of charge, to any person obtaining a copy</span>
0802 <span class="comment">% of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
0803 <span class="comment">% in the Software without restriction, including without limitation the rights</span>
0804 <span class="comment">% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
0805 <span class="comment">% copies of the Software, and to permit persons to whom the Software is</span>
0806 <span class="comment">% furnished to do so, subject to the following conditions:</span>
0807 <span class="comment">%</span>
0808 <span class="comment">% The above copyright notice and this permission notice shall be included in all</span>
0809 <span class="comment">% copies or substantial portions of the Software.</span>
0810 <span class="comment">%</span>
0811 <span class="comment">% THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
0812 <span class="comment">% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
0813 <span class="comment">% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
0814 <span class="comment">% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
0815 <span class="comment">% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
0816 <span class="comment">% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
0817 <span class="comment">% SOFTWARE.</span></pre></div>
<hr><address>Generated by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>